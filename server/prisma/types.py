# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = Literal['default', 'insensitive']
SortOrder = Literal['asc', 'desc']

MetricsFormat = Literal['json', 'prometheus']


class _DatasourceOverrideOptional(TypedDict, total=False):
    env: str
    name: str


class DatasourceOverride(_DatasourceOverrideOptional):
    url: str


# NOTE: we don't support some options as their type hints are not publicly exposed
# https://github.com/encode/httpx/discussions/1977
class HttpConfig(TypedDict, total=False):
    app: Callable[[Mapping[str, Any], Any], Any]
    http1: bool
    http2: bool
    limits: httpx.Limits
    timeout: Union[None, float, httpx.Timeout]
    trust_env: bool
    max_redirects: int


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List['Serializable'],
    Dict[None, 'Serializable'],
    Dict[bool, 'Serializable'],
    Dict[float, 'Serializable'],
    Dict[int, 'Serializable'],
    Dict[str, 'Serializable'],
]


StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilter'],
        'mode': SortMode,
    },
    total=False,
)



class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilter'],
    },
    total=False,
)



class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilter'],
    },
    total=False,
)



class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilter'],
    },
    total=False,
)



class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilter'],
    },
    total=False,
)



class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilter'],
    },
    total=False,
)



class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilter'],
    },
    total=False,
)



class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]

class _MealTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.MealType']]


class _MealTypeListFilterHasInput(TypedDict):
    has: 'enums.MealType'


class _MealTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.MealType']


class _MealTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.MealType']


class _MealTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


MealTypeListFilter = Union[
    _MealTypeListFilterHasInput,
    _MealTypeListFilterEqualsInput,
    _MealTypeListFilterHasSomeInput,
    _MealTypeListFilterIsEmptyInput,
    _MealTypeListFilterHasEveryInput,
]


class _MealTypeListUpdateSet(TypedDict):
    set: List['enums.MealType']


class _MealTypeListUpdatePush(TypedDict):
    push: List['enums.MealType']


MealTypeListUpdate = Union[
    List['enums.MealType'],
    _MealTypeListUpdateSet,
    _MealTypeListUpdatePush,
]


# Profile types

class ProfileOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Profile create method"""
    id: _str
    imageUrl: Optional[_str]
    public: _bool
    followsFollowing: 'FollowCreateManyNestedWithoutRelationsInput'
    followsFollowed: 'FollowCreateManyNestedWithoutRelationsInput'
    posts: 'PostCreateManyNestedWithoutRelationsInput'
    postTags: 'PostTagCreateManyNestedWithoutRelationsInput'
    members: 'MemberCreateManyNestedWithoutRelationsInput'
    comments: 'CommentCreateManyNestedWithoutRelationsInput'
    postLikes: 'PostLikeCreateManyNestedWithoutRelationsInput'
    commentLikes: 'CommentLikeCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ProfileCreateInput(ProfileOptionalCreateInput):
    """Required arguments to the Profile create method"""
    email: _str
    username: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ProfileOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Profile create method, without relations"""
    id: _str
    imageUrl: Optional[_str]
    public: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ProfileCreateWithoutRelationsInput(ProfileOptionalCreateWithoutRelationsInput):
    """Required arguments to the Profile create method, without relations"""
    email: _str
    username: _str


class ProfileCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ProfileCreateWithoutRelationsInput'
    connect: 'ProfileWhereUniqueInput'


class ProfileCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ProfileCreateWithoutRelationsInput', List['ProfileCreateWithoutRelationsInput']]
    connect: Union['ProfileWhereUniqueInput', List['ProfileWhereUniqueInput']]


_ProfileWhereUnique_id_Input = TypedDict(
    '_ProfileWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_ProfileWhereUnique_email_Input = TypedDict(
    '_ProfileWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

_ProfileWhereUnique_username_Input = TypedDict(
    '_ProfileWhereUnique_username_Input',
    {
        'username': '_str',
    },
    total=True
)

ProfileWhereUniqueInput = Union[
    '_ProfileWhereUnique_id_Input',
    '_ProfileWhereUnique_email_Input',
    '_ProfileWhereUnique_username_Input',
]


class ProfileUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    email: _str
    username: _str
    imageUrl: Optional[_str]
    public: _bool
    followsFollowing: 'FollowUpdateManyWithoutRelationsInput'
    followsFollowed: 'FollowUpdateManyWithoutRelationsInput'
    posts: 'PostUpdateManyWithoutRelationsInput'
    postTags: 'PostTagUpdateManyWithoutRelationsInput'
    members: 'MemberUpdateManyWithoutRelationsInput'
    comments: 'CommentUpdateManyWithoutRelationsInput'
    postLikes: 'PostLikeUpdateManyWithoutRelationsInput'
    commentLikes: 'CommentLikeUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ProfileUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    email: _str
    username: _str
    imageUrl: Optional[_str]
    public: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ProfileUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ProfileCreateWithoutRelationsInput']
    connect: List['ProfileWhereUniqueInput']
    set: List['ProfileWhereUniqueInput']
    disconnect: List['ProfileWhereUniqueInput']
    delete: List['ProfileWhereUniqueInput']

    # TODO
    # update: List['ProfileUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ProfileUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ProfileScalarWhereInput']
    # upsert: List['ProfileUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['ProfileCreateOrConnectWithoutRelationsInput']


class ProfileUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ProfileCreateWithoutRelationsInput'
    connect: 'ProfileWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ProfileUpdateInput'
    # upsert: 'ProfileUpsertWithoutRelationsInput'
    # connectOrCreate: 'ProfileCreateOrConnectWithoutRelationsInput'


class ProfileUpsertInput(TypedDict):
    create: 'ProfileCreateInput'
    update: 'ProfileUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Profile_id_OrderByInput = TypedDict(
    '_Profile_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Profile_email_OrderByInput = TypedDict(
    '_Profile_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Profile_username_OrderByInput = TypedDict(
    '_Profile_username_OrderByInput',
    {
        'username': 'SortOrder',
    },
    total=True
)

_Profile_imageUrl_OrderByInput = TypedDict(
    '_Profile_imageUrl_OrderByInput',
    {
        'imageUrl': 'SortOrder',
    },
    total=True
)

_Profile_public_OrderByInput = TypedDict(
    '_Profile_public_OrderByInput',
    {
        'public': 'SortOrder',
    },
    total=True
)

_Profile_createdAt_OrderByInput = TypedDict(
    '_Profile_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Profile_updatedAt_OrderByInput = TypedDict(
    '_Profile_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

ProfileOrderByInput = Union[
    '_Profile_id_OrderByInput',
    '_Profile_email_OrderByInput',
    '_Profile_username_OrderByInput',
    '_Profile_imageUrl_OrderByInput',
    '_Profile_public_OrderByInput',
    '_Profile_createdAt_OrderByInput',
    '_Profile_updatedAt_OrderByInput',
]



# recursive Profile types
# TODO: cleanup these types



ProfileRelationFilter = TypedDict(
    'ProfileRelationFilter',
    {
        'is': 'ProfileWhereInput',
        'is_not': 'ProfileWhereInput',
    },
    total=False,
)


class ProfileListRelationFilter(TypedDict, total=False):
    some: 'ProfileWhereInput'
    none: 'ProfileWhereInput'
    every: 'ProfileWhereInput'


class ProfileInclude(TypedDict, total=False):
    """Profile relational arguments"""
    followsFollowing: Union[bool, 'FindManyFollowArgsFromProfile']
    followsFollowed: Union[bool, 'FindManyFollowArgsFromProfile']
    posts: Union[bool, 'FindManyPostArgsFromProfile']
    postTags: Union[bool, 'FindManyPostTagArgsFromProfile']
    members: Union[bool, 'FindManyMemberArgsFromProfile']
    comments: Union[bool, 'FindManyCommentArgsFromProfile']
    postLikes: Union[bool, 'FindManyPostLikeArgsFromProfile']
    commentLikes: Union[bool, 'FindManyCommentLikeArgsFromProfile']


class ProfileIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    followsFollowing: Union[bool, 'FindManyFollowArgsFromProfile']
    followsFollowed: Union[bool, 'FindManyFollowArgsFromProfile']
    posts: Union[bool, 'FindManyPostArgsFromProfile']
    postTags: Union[bool, 'FindManyPostTagArgsFromProfile']
    members: Union[bool, 'FindManyMemberArgsFromProfile']
    comments: Union[bool, 'FindManyCommentArgsFromProfile']
    postLikes: Union[bool, 'FindManyPostLikeArgsFromProfile']
    commentLikes: Union[bool, 'FindManyCommentLikeArgsFromProfile']


class ProfileArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'ProfileIncludeFromProfile'


class FindManyProfileArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfile'


class FollowIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    following: Union[bool, 'ProfileArgsFromProfile']
    followed: Union[bool, 'ProfileArgsFromProfile']


class FollowArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'FollowIncludeFromFollow'


class FindManyFollowArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['FollowOrderByInput', List['FollowOrderByInput']]
    where: 'FollowWhereInput'
    cursor: 'FollowWhereUniqueInput'
    distinct: List['FollowScalarFieldKeys']
    include: 'FollowIncludeFromFollow'


class PostIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    restaurant: Union[bool, 'RestaurantArgsFromProfile']
    group: Union[bool, 'GroupArgsFromProfile']
    profile: Union[bool, 'ProfileArgsFromProfile']
    comments: Union[bool, 'FindManyCommentArgsFromProfile']
    likes: Union[bool, 'FindManyPostLikeArgsFromProfile']
    postTags: Union[bool, 'FindManyPostTagArgsFromProfile']
    postImages: Union[bool, 'FindManyPostImageArgsFromProfile']


class PostArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'PostIncludeFromPost'


class FindManyPostArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPost'


class PostTagIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    post: Union[bool, 'PostArgsFromProfile']
    profile: Union[bool, 'ProfileArgsFromProfile']


class PostTagArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'PostTagIncludeFromPostTag'


class FindManyPostTagArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['PostTagOrderByInput', List['PostTagOrderByInput']]
    where: 'PostTagWhereInput'
    cursor: 'PostTagWhereUniqueInput'
    distinct: List['PostTagScalarFieldKeys']
    include: 'PostTagIncludeFromPostTag'


class PostImageIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    post: Union[bool, 'PostArgsFromProfile']


class PostImageArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'PostImageIncludeFromPostImage'


class FindManyPostImageArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['PostImageOrderByInput', List['PostImageOrderByInput']]
    where: 'PostImageWhereInput'
    cursor: 'PostImageWhereUniqueInput'
    distinct: List['PostImageScalarFieldKeys']
    include: 'PostImageIncludeFromPostImage'


class GroupIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    members: Union[bool, 'FindManyMemberArgsFromProfile']
    posts: Union[bool, 'FindManyPostArgsFromProfile']


class GroupArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'GroupIncludeFromGroup'


class FindManyGroupArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['GroupOrderByInput', List['GroupOrderByInput']]
    where: 'GroupWhereInput'
    cursor: 'GroupWhereUniqueInput'
    distinct: List['GroupScalarFieldKeys']
    include: 'GroupIncludeFromGroup'


class MemberIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    profile: Union[bool, 'ProfileArgsFromProfile']
    group: Union[bool, 'GroupArgsFromProfile']


class MemberArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'MemberIncludeFromMember'


class FindManyMemberArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMember'


class CommentIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    replies: Union[bool, 'FindManyCommentArgsFromProfile']
    likes: Union[bool, 'FindManyCommentLikeArgsFromProfile']
    parent: Union[bool, 'CommentArgsFromProfile']
    post: Union[bool, 'PostArgsFromProfile']
    profile: Union[bool, 'ProfileArgsFromProfile']


class CommentArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'CommentIncludeFromComment'


class FindManyCommentArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromComment'


class PostLikeIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    post: Union[bool, 'PostArgsFromProfile']
    profile: Union[bool, 'ProfileArgsFromProfile']


class PostLikeArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'PostLikeIncludeFromPostLike'


class FindManyPostLikeArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['PostLikeOrderByInput', List['PostLikeOrderByInput']]
    where: 'PostLikeWhereInput'
    cursor: 'PostLikeWhereUniqueInput'
    distinct: List['PostLikeScalarFieldKeys']
    include: 'PostLikeIncludeFromPostLike'


class CommentLikeIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    comment: Union[bool, 'CommentArgsFromProfile']
    profile: Union[bool, 'ProfileArgsFromProfile']


class CommentLikeArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'CommentLikeIncludeFromCommentLike'


class FindManyCommentLikeArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['CommentLikeOrderByInput', List['CommentLikeOrderByInput']]
    where: 'CommentLikeWhereInput'
    cursor: 'CommentLikeWhereUniqueInput'
    distinct: List['CommentLikeScalarFieldKeys']
    include: 'CommentLikeIncludeFromCommentLike'


class RestaurantIncludeFromProfile(TypedDict, total=False):
    """Relational arguments for Profile"""
    posts: Union[bool, 'FindManyPostArgsFromProfile']


class RestaurantArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    include: 'RestaurantIncludeFromRestaurant'


class FindManyRestaurantArgsFromProfile(TypedDict, total=False):
    """Arguments for Profile"""
    take: int
    skip: int
    order_by: Union['RestaurantOrderByInput', List['RestaurantOrderByInput']]
    where: 'RestaurantWhereInput'
    cursor: 'RestaurantWhereUniqueInput'
    distinct: List['RestaurantScalarFieldKeys']
    include: 'RestaurantIncludeFromRestaurant'




FindManyProfileArgs = FindManyProfileArgsFromProfile
FindFirstProfileArgs = FindManyProfileArgsFromProfile


class ProfileWhereInput(TypedDict, total=False):
    """Profile arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    imageUrl: Union[None, _str, 'types.StringFilter']
    public: Union[_bool, 'types.BooleanFilter']
    followsFollowing: 'FollowListRelationFilter'
    followsFollowed: 'FollowListRelationFilter'
    posts: 'PostListRelationFilter'
    postTags: 'PostTagListRelationFilter'
    members: 'MemberListRelationFilter'
    comments: 'CommentListRelationFilter'
    postLikes: 'PostLikeListRelationFilter'
    commentLikes: 'CommentLikeListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ProfileWhereInput', List['ProfileWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ProfileWhereInput']
    OR: List['ProfileWhereInput']
    NOT: List['ProfileWhereInput']



# aggregate Profile types


class ProfileScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Profile arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    imageUrl: Union[_str, 'types.StringWithAggregatesFilter']
    public: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProfileScalarWhereWithAggregatesInput']
    OR: List['ProfileScalarWhereWithAggregatesInput']
    NOT: List['ProfileScalarWhereWithAggregatesInput']



class ProfileGroupByOutput(TypedDict, total=False):
    id: _str
    email: _str
    username: _str
    imageUrl: _str
    public: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'ProfileSumAggregateOutput'
    _avg: 'ProfileAvgAggregateOutput'
    _min: 'ProfileMinAggregateOutput'
    _max: 'ProfileMaxAggregateOutput'
    _count: 'ProfileCountAggregateOutput'


class ProfileAvgAggregateOutput(TypedDict, total=False):
    """Profile output for aggregating averages"""


class ProfileSumAggregateOutput(TypedDict, total=False):
    """Profile output for aggregating sums"""


class ProfileScalarAggregateOutput(TypedDict, total=False):
    """Profile output including scalar fields"""
    id: _str
    email: _str
    username: _str
    imageUrl: _str
    public: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


ProfileMinAggregateOutput = ProfileScalarAggregateOutput
ProfileMaxAggregateOutput = ProfileScalarAggregateOutput


class ProfileMaxAggregateInput(TypedDict, total=False):
    """Profile input for aggregating by max"""
    id: bool
    email: bool
    username: bool
    imageUrl: bool
    public: bool
    createdAt: bool
    updatedAt: bool


class ProfileMinAggregateInput(TypedDict, total=False):
    """Profile input for aggregating by min"""
    id: bool
    email: bool
    username: bool
    imageUrl: bool
    public: bool
    createdAt: bool
    updatedAt: bool


class ProfileNumberAggregateInput(TypedDict, total=False):
    """Profile input for aggregating numbers"""


ProfileAvgAggregateInput = ProfileNumberAggregateInput
ProfileSumAggregateInput = ProfileNumberAggregateInput


ProfileCountAggregateInput = TypedDict(
    'ProfileCountAggregateInput',
    {
        'id': bool,
        'email': bool,
        'username': bool,
        'imageUrl': bool,
        'public': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

ProfileCountAggregateOutput = TypedDict(
    'ProfileCountAggregateOutput',
    {
        'id': int,
        'email': int,
        'username': int,
        'imageUrl': int,
        'public': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


ProfileKeys = Literal[
    'id',
    'email',
    'username',
    'imageUrl',
    'public',
    'followsFollowing',
    'followsFollowed',
    'posts',
    'postTags',
    'members',
    'comments',
    'postLikes',
    'commentLikes',
    'createdAt',
    'updatedAt',
]
ProfileScalarFieldKeys = Literal[
    'id',
    'email',
    'username',
    'imageUrl',
    'public',
    'createdAt',
    'updatedAt',
]
ProfileScalarFieldKeysT = TypeVar('ProfileScalarFieldKeysT', bound=ProfileScalarFieldKeys)

ProfileRelationalFieldKeys = Literal[
        'followsFollowing',
        'followsFollowed',
        'posts',
        'postTags',
        'members',
        'comments',
        'postLikes',
        'commentLikes',
    ]

# Follow types

class FollowOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Follow create method"""
    id: _str
    following: 'ProfileCreateNestedWithoutRelationsInput'
    followingId: _str
    followed: 'ProfileCreateNestedWithoutRelationsInput'
    followedId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class FollowCreateInput(FollowOptionalCreateInput):
    """Required arguments to the Follow create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class FollowOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Follow create method, without relations"""
    id: _str
    followingId: _str
    followedId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class FollowCreateWithoutRelationsInput(FollowOptionalCreateWithoutRelationsInput):
    """Required arguments to the Follow create method, without relations"""


class FollowCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'FollowCreateWithoutRelationsInput'
    connect: 'FollowWhereUniqueInput'


class FollowCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['FollowCreateWithoutRelationsInput', List['FollowCreateWithoutRelationsInput']]
    connect: Union['FollowWhereUniqueInput', List['FollowWhereUniqueInput']]


_FollowWhereUnique_id_Input = TypedDict(
    '_FollowWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

FollowWhereUniqueInput = _FollowWhereUnique_id_Input


class FollowUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    following: 'ProfileUpdateOneWithoutRelationsInput'
    followed: 'ProfileUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class FollowUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class FollowUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['FollowCreateWithoutRelationsInput']
    connect: List['FollowWhereUniqueInput']
    set: List['FollowWhereUniqueInput']
    disconnect: List['FollowWhereUniqueInput']
    delete: List['FollowWhereUniqueInput']

    # TODO
    # update: List['FollowUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['FollowUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['FollowScalarWhereInput']
    # upsert: List['FollowUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['FollowCreateOrConnectWithoutRelationsInput']


class FollowUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'FollowCreateWithoutRelationsInput'
    connect: 'FollowWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'FollowUpdateInput'
    # upsert: 'FollowUpsertWithoutRelationsInput'
    # connectOrCreate: 'FollowCreateOrConnectWithoutRelationsInput'


class FollowUpsertInput(TypedDict):
    create: 'FollowCreateInput'
    update: 'FollowUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Follow_id_OrderByInput = TypedDict(
    '_Follow_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Follow_followingId_OrderByInput = TypedDict(
    '_Follow_followingId_OrderByInput',
    {
        'followingId': 'SortOrder',
    },
    total=True
)

_Follow_followedId_OrderByInput = TypedDict(
    '_Follow_followedId_OrderByInput',
    {
        'followedId': 'SortOrder',
    },
    total=True
)

_Follow_createdAt_OrderByInput = TypedDict(
    '_Follow_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Follow_updatedAt_OrderByInput = TypedDict(
    '_Follow_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

FollowOrderByInput = Union[
    '_Follow_id_OrderByInput',
    '_Follow_followingId_OrderByInput',
    '_Follow_followedId_OrderByInput',
    '_Follow_createdAt_OrderByInput',
    '_Follow_updatedAt_OrderByInput',
]



# recursive Follow types
# TODO: cleanup these types



FollowRelationFilter = TypedDict(
    'FollowRelationFilter',
    {
        'is': 'FollowWhereInput',
        'is_not': 'FollowWhereInput',
    },
    total=False,
)


class FollowListRelationFilter(TypedDict, total=False):
    some: 'FollowWhereInput'
    none: 'FollowWhereInput'
    every: 'FollowWhereInput'


class FollowInclude(TypedDict, total=False):
    """Follow relational arguments"""
    following: Union[bool, 'ProfileArgsFromFollow']
    followed: Union[bool, 'ProfileArgsFromFollow']


class ProfileIncludeFromFollow(TypedDict, total=False):
    """Relational arguments for Follow"""
    followsFollowing: Union[bool, 'FindManyFollowArgsFromFollow']
    followsFollowed: Union[bool, 'FindManyFollowArgsFromFollow']
    posts: Union[bool, 'FindManyPostArgsFromFollow']
    postTags: Union[bool, 'FindManyPostTagArgsFromFollow']
    members: Union[bool, 'FindManyMemberArgsFromFollow']
    comments: Union[bool, 'FindManyCommentArgsFromFollow']
    postLikes: Union[bool, 'FindManyPostLikeArgsFromFollow']
    commentLikes: Union[bool, 'FindManyCommentLikeArgsFromFollow']


class ProfileArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    include: 'ProfileIncludeFromProfile'


class FindManyProfileArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfile'


class FollowIncludeFromFollow(TypedDict, total=False):
    """Relational arguments for Follow"""
    following: Union[bool, 'ProfileArgsFromFollow']
    followed: Union[bool, 'ProfileArgsFromFollow']


class FollowArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    include: 'FollowIncludeFromFollow'


class FindManyFollowArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    take: int
    skip: int
    order_by: Union['FollowOrderByInput', List['FollowOrderByInput']]
    where: 'FollowWhereInput'
    cursor: 'FollowWhereUniqueInput'
    distinct: List['FollowScalarFieldKeys']
    include: 'FollowIncludeFromFollow'


class PostIncludeFromFollow(TypedDict, total=False):
    """Relational arguments for Follow"""
    restaurant: Union[bool, 'RestaurantArgsFromFollow']
    group: Union[bool, 'GroupArgsFromFollow']
    profile: Union[bool, 'ProfileArgsFromFollow']
    comments: Union[bool, 'FindManyCommentArgsFromFollow']
    likes: Union[bool, 'FindManyPostLikeArgsFromFollow']
    postTags: Union[bool, 'FindManyPostTagArgsFromFollow']
    postImages: Union[bool, 'FindManyPostImageArgsFromFollow']


class PostArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    include: 'PostIncludeFromPost'


class FindManyPostArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPost'


class PostTagIncludeFromFollow(TypedDict, total=False):
    """Relational arguments for Follow"""
    post: Union[bool, 'PostArgsFromFollow']
    profile: Union[bool, 'ProfileArgsFromFollow']


class PostTagArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    include: 'PostTagIncludeFromPostTag'


class FindManyPostTagArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    take: int
    skip: int
    order_by: Union['PostTagOrderByInput', List['PostTagOrderByInput']]
    where: 'PostTagWhereInput'
    cursor: 'PostTagWhereUniqueInput'
    distinct: List['PostTagScalarFieldKeys']
    include: 'PostTagIncludeFromPostTag'


class PostImageIncludeFromFollow(TypedDict, total=False):
    """Relational arguments for Follow"""
    post: Union[bool, 'PostArgsFromFollow']


class PostImageArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    include: 'PostImageIncludeFromPostImage'


class FindManyPostImageArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    take: int
    skip: int
    order_by: Union['PostImageOrderByInput', List['PostImageOrderByInput']]
    where: 'PostImageWhereInput'
    cursor: 'PostImageWhereUniqueInput'
    distinct: List['PostImageScalarFieldKeys']
    include: 'PostImageIncludeFromPostImage'


class GroupIncludeFromFollow(TypedDict, total=False):
    """Relational arguments for Follow"""
    members: Union[bool, 'FindManyMemberArgsFromFollow']
    posts: Union[bool, 'FindManyPostArgsFromFollow']


class GroupArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    include: 'GroupIncludeFromGroup'


class FindManyGroupArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    take: int
    skip: int
    order_by: Union['GroupOrderByInput', List['GroupOrderByInput']]
    where: 'GroupWhereInput'
    cursor: 'GroupWhereUniqueInput'
    distinct: List['GroupScalarFieldKeys']
    include: 'GroupIncludeFromGroup'


class MemberIncludeFromFollow(TypedDict, total=False):
    """Relational arguments for Follow"""
    profile: Union[bool, 'ProfileArgsFromFollow']
    group: Union[bool, 'GroupArgsFromFollow']


class MemberArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    include: 'MemberIncludeFromMember'


class FindManyMemberArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMember'


class CommentIncludeFromFollow(TypedDict, total=False):
    """Relational arguments for Follow"""
    replies: Union[bool, 'FindManyCommentArgsFromFollow']
    likes: Union[bool, 'FindManyCommentLikeArgsFromFollow']
    parent: Union[bool, 'CommentArgsFromFollow']
    post: Union[bool, 'PostArgsFromFollow']
    profile: Union[bool, 'ProfileArgsFromFollow']


class CommentArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    include: 'CommentIncludeFromComment'


class FindManyCommentArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromComment'


class PostLikeIncludeFromFollow(TypedDict, total=False):
    """Relational arguments for Follow"""
    post: Union[bool, 'PostArgsFromFollow']
    profile: Union[bool, 'ProfileArgsFromFollow']


class PostLikeArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    include: 'PostLikeIncludeFromPostLike'


class FindManyPostLikeArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    take: int
    skip: int
    order_by: Union['PostLikeOrderByInput', List['PostLikeOrderByInput']]
    where: 'PostLikeWhereInput'
    cursor: 'PostLikeWhereUniqueInput'
    distinct: List['PostLikeScalarFieldKeys']
    include: 'PostLikeIncludeFromPostLike'


class CommentLikeIncludeFromFollow(TypedDict, total=False):
    """Relational arguments for Follow"""
    comment: Union[bool, 'CommentArgsFromFollow']
    profile: Union[bool, 'ProfileArgsFromFollow']


class CommentLikeArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    include: 'CommentLikeIncludeFromCommentLike'


class FindManyCommentLikeArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    take: int
    skip: int
    order_by: Union['CommentLikeOrderByInput', List['CommentLikeOrderByInput']]
    where: 'CommentLikeWhereInput'
    cursor: 'CommentLikeWhereUniqueInput'
    distinct: List['CommentLikeScalarFieldKeys']
    include: 'CommentLikeIncludeFromCommentLike'


class RestaurantIncludeFromFollow(TypedDict, total=False):
    """Relational arguments for Follow"""
    posts: Union[bool, 'FindManyPostArgsFromFollow']


class RestaurantArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    include: 'RestaurantIncludeFromRestaurant'


class FindManyRestaurantArgsFromFollow(TypedDict, total=False):
    """Arguments for Follow"""
    take: int
    skip: int
    order_by: Union['RestaurantOrderByInput', List['RestaurantOrderByInput']]
    where: 'RestaurantWhereInput'
    cursor: 'RestaurantWhereUniqueInput'
    distinct: List['RestaurantScalarFieldKeys']
    include: 'RestaurantIncludeFromRestaurant'




FindManyFollowArgs = FindManyFollowArgsFromFollow
FindFirstFollowArgs = FindManyFollowArgsFromFollow


class FollowWhereInput(TypedDict, total=False):
    """Follow arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    following: 'ProfileRelationFilter'
    followingId: Union[_str, 'types.StringFilter']
    followed: 'ProfileRelationFilter'
    followedId: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['FollowWhereInput', List['FollowWhereInput']]
    # but this causes mypy to hang :/
    AND: List['FollowWhereInput']
    OR: List['FollowWhereInput']
    NOT: List['FollowWhereInput']



# aggregate Follow types


class FollowScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Follow arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    followingId: Union[_str, 'types.StringWithAggregatesFilter']
    followedId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['FollowScalarWhereWithAggregatesInput']
    OR: List['FollowScalarWhereWithAggregatesInput']
    NOT: List['FollowScalarWhereWithAggregatesInput']



class FollowGroupByOutput(TypedDict, total=False):
    id: _str
    followingId: _str
    followedId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'FollowSumAggregateOutput'
    _avg: 'FollowAvgAggregateOutput'
    _min: 'FollowMinAggregateOutput'
    _max: 'FollowMaxAggregateOutput'
    _count: 'FollowCountAggregateOutput'


class FollowAvgAggregateOutput(TypedDict, total=False):
    """Follow output for aggregating averages"""


class FollowSumAggregateOutput(TypedDict, total=False):
    """Follow output for aggregating sums"""


class FollowScalarAggregateOutput(TypedDict, total=False):
    """Follow output including scalar fields"""
    id: _str
    followingId: _str
    followedId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


FollowMinAggregateOutput = FollowScalarAggregateOutput
FollowMaxAggregateOutput = FollowScalarAggregateOutput


class FollowMaxAggregateInput(TypedDict, total=False):
    """Follow input for aggregating by max"""
    id: bool
    followingId: bool
    followedId: bool
    createdAt: bool
    updatedAt: bool


class FollowMinAggregateInput(TypedDict, total=False):
    """Follow input for aggregating by min"""
    id: bool
    followingId: bool
    followedId: bool
    createdAt: bool
    updatedAt: bool


class FollowNumberAggregateInput(TypedDict, total=False):
    """Follow input for aggregating numbers"""


FollowAvgAggregateInput = FollowNumberAggregateInput
FollowSumAggregateInput = FollowNumberAggregateInput


FollowCountAggregateInput = TypedDict(
    'FollowCountAggregateInput',
    {
        'id': bool,
        'followingId': bool,
        'followedId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

FollowCountAggregateOutput = TypedDict(
    'FollowCountAggregateOutput',
    {
        'id': int,
        'followingId': int,
        'followedId': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


FollowKeys = Literal[
    'id',
    'following',
    'followingId',
    'followed',
    'followedId',
    'createdAt',
    'updatedAt',
]
FollowScalarFieldKeys = Literal[
    'id',
    'followingId',
    'followedId',
    'createdAt',
    'updatedAt',
]
FollowScalarFieldKeysT = TypeVar('FollowScalarFieldKeysT', bound=FollowScalarFieldKeys)

FollowRelationalFieldKeys = Literal[
        'following',
        'followed',
    ]

# Post types

class PostOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Post create method"""
    id: _str
    restaurant: 'RestaurantCreateNestedWithoutRelationsInput'
    restaurantId: _str
    group: 'GroupCreateNestedWithoutRelationsInput'
    groupId: Optional[_str]
    profile: 'ProfileCreateNestedWithoutRelationsInput'
    profileId: Optional[_str]
    comments: 'CommentCreateManyNestedWithoutRelationsInput'
    likes: 'PostLikeCreateManyNestedWithoutRelationsInput'
    postTags: 'PostTagCreateManyNestedWithoutRelationsInput'
    postImages: 'PostImageCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostCreateInput(PostOptionalCreateInput):
    """Required arguments to the Post create method"""
    individual: _bool
    meal: 'enums.MealType'
    review: _str
    rating: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PostOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Post create method, without relations"""
    id: _str
    restaurantId: _str
    groupId: Optional[_str]
    profileId: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostCreateWithoutRelationsInput(PostOptionalCreateWithoutRelationsInput):
    """Required arguments to the Post create method, without relations"""
    individual: _bool
    meal: 'enums.MealType'
    review: _str
    rating: _int


class PostCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PostCreateWithoutRelationsInput'
    connect: 'PostWhereUniqueInput'


class PostCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PostCreateWithoutRelationsInput', List['PostCreateWithoutRelationsInput']]
    connect: Union['PostWhereUniqueInput', List['PostWhereUniqueInput']]


_PostWhereUnique_id_Input = TypedDict(
    '_PostWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

PostWhereUniqueInput = _PostWhereUnique_id_Input


class PostUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    individual: _bool
    meal: 'enums.MealType'
    restaurant: 'RestaurantUpdateOneWithoutRelationsInput'
    group: 'GroupUpdateOneWithoutRelationsInput'
    profile: 'ProfileUpdateOneWithoutRelationsInput'
    comments: 'CommentUpdateManyWithoutRelationsInput'
    likes: 'PostLikeUpdateManyWithoutRelationsInput'
    postTags: 'PostTagUpdateManyWithoutRelationsInput'
    postImages: 'PostImageUpdateManyWithoutRelationsInput'
    review: _str
    rating: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    individual: _bool
    meal: 'enums.MealType'
    review: _str
    rating: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PostCreateWithoutRelationsInput']
    connect: List['PostWhereUniqueInput']
    set: List['PostWhereUniqueInput']
    disconnect: List['PostWhereUniqueInput']
    delete: List['PostWhereUniqueInput']

    # TODO
    # update: List['PostUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PostUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PostScalarWhereInput']
    # upsert: List['PostUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['PostCreateOrConnectWithoutRelationsInput']


class PostUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PostCreateWithoutRelationsInput'
    connect: 'PostWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PostUpdateInput'
    # upsert: 'PostUpsertWithoutRelationsInput'
    # connectOrCreate: 'PostCreateOrConnectWithoutRelationsInput'


class PostUpsertInput(TypedDict):
    create: 'PostCreateInput'
    update: 'PostUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Post_id_OrderByInput = TypedDict(
    '_Post_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Post_individual_OrderByInput = TypedDict(
    '_Post_individual_OrderByInput',
    {
        'individual': 'SortOrder',
    },
    total=True
)

_Post_meal_OrderByInput = TypedDict(
    '_Post_meal_OrderByInput',
    {
        'meal': 'SortOrder',
    },
    total=True
)

_Post_restaurantId_OrderByInput = TypedDict(
    '_Post_restaurantId_OrderByInput',
    {
        'restaurantId': 'SortOrder',
    },
    total=True
)

_Post_groupId_OrderByInput = TypedDict(
    '_Post_groupId_OrderByInput',
    {
        'groupId': 'SortOrder',
    },
    total=True
)

_Post_profileId_OrderByInput = TypedDict(
    '_Post_profileId_OrderByInput',
    {
        'profileId': 'SortOrder',
    },
    total=True
)

_Post_review_OrderByInput = TypedDict(
    '_Post_review_OrderByInput',
    {
        'review': 'SortOrder',
    },
    total=True
)

_Post_rating_OrderByInput = TypedDict(
    '_Post_rating_OrderByInput',
    {
        'rating': 'SortOrder',
    },
    total=True
)

_Post_createdAt_OrderByInput = TypedDict(
    '_Post_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Post_updatedAt_OrderByInput = TypedDict(
    '_Post_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

PostOrderByInput = Union[
    '_Post_id_OrderByInput',
    '_Post_individual_OrderByInput',
    '_Post_meal_OrderByInput',
    '_Post_restaurantId_OrderByInput',
    '_Post_groupId_OrderByInput',
    '_Post_profileId_OrderByInput',
    '_Post_review_OrderByInput',
    '_Post_rating_OrderByInput',
    '_Post_createdAt_OrderByInput',
    '_Post_updatedAt_OrderByInput',
]



# recursive Post types
# TODO: cleanup these types



PostRelationFilter = TypedDict(
    'PostRelationFilter',
    {
        'is': 'PostWhereInput',
        'is_not': 'PostWhereInput',
    },
    total=False,
)


class PostListRelationFilter(TypedDict, total=False):
    some: 'PostWhereInput'
    none: 'PostWhereInput'
    every: 'PostWhereInput'


class PostInclude(TypedDict, total=False):
    """Post relational arguments"""
    restaurant: Union[bool, 'RestaurantArgsFromPost']
    group: Union[bool, 'GroupArgsFromPost']
    profile: Union[bool, 'ProfileArgsFromPost']
    comments: Union[bool, 'FindManyCommentArgsFromPost']
    likes: Union[bool, 'FindManyPostLikeArgsFromPost']
    postTags: Union[bool, 'FindManyPostTagArgsFromPost']
    postImages: Union[bool, 'FindManyPostImageArgsFromPost']


class ProfileIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    followsFollowing: Union[bool, 'FindManyFollowArgsFromPost']
    followsFollowed: Union[bool, 'FindManyFollowArgsFromPost']
    posts: Union[bool, 'FindManyPostArgsFromPost']
    postTags: Union[bool, 'FindManyPostTagArgsFromPost']
    members: Union[bool, 'FindManyMemberArgsFromPost']
    comments: Union[bool, 'FindManyCommentArgsFromPost']
    postLikes: Union[bool, 'FindManyPostLikeArgsFromPost']
    commentLikes: Union[bool, 'FindManyCommentLikeArgsFromPost']


class ProfileArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'ProfileIncludeFromProfile'


class FindManyProfileArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfile'


class FollowIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    following: Union[bool, 'ProfileArgsFromPost']
    followed: Union[bool, 'ProfileArgsFromPost']


class FollowArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'FollowIncludeFromFollow'


class FindManyFollowArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['FollowOrderByInput', List['FollowOrderByInput']]
    where: 'FollowWhereInput'
    cursor: 'FollowWhereUniqueInput'
    distinct: List['FollowScalarFieldKeys']
    include: 'FollowIncludeFromFollow'


class PostIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    restaurant: Union[bool, 'RestaurantArgsFromPost']
    group: Union[bool, 'GroupArgsFromPost']
    profile: Union[bool, 'ProfileArgsFromPost']
    comments: Union[bool, 'FindManyCommentArgsFromPost']
    likes: Union[bool, 'FindManyPostLikeArgsFromPost']
    postTags: Union[bool, 'FindManyPostTagArgsFromPost']
    postImages: Union[bool, 'FindManyPostImageArgsFromPost']


class PostArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'PostIncludeFromPost'


class FindManyPostArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPost'


class PostTagIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    post: Union[bool, 'PostArgsFromPost']
    profile: Union[bool, 'ProfileArgsFromPost']


class PostTagArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'PostTagIncludeFromPostTag'


class FindManyPostTagArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['PostTagOrderByInput', List['PostTagOrderByInput']]
    where: 'PostTagWhereInput'
    cursor: 'PostTagWhereUniqueInput'
    distinct: List['PostTagScalarFieldKeys']
    include: 'PostTagIncludeFromPostTag'


class PostImageIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    post: Union[bool, 'PostArgsFromPost']


class PostImageArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'PostImageIncludeFromPostImage'


class FindManyPostImageArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['PostImageOrderByInput', List['PostImageOrderByInput']]
    where: 'PostImageWhereInput'
    cursor: 'PostImageWhereUniqueInput'
    distinct: List['PostImageScalarFieldKeys']
    include: 'PostImageIncludeFromPostImage'


class GroupIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    members: Union[bool, 'FindManyMemberArgsFromPost']
    posts: Union[bool, 'FindManyPostArgsFromPost']


class GroupArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'GroupIncludeFromGroup'


class FindManyGroupArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['GroupOrderByInput', List['GroupOrderByInput']]
    where: 'GroupWhereInput'
    cursor: 'GroupWhereUniqueInput'
    distinct: List['GroupScalarFieldKeys']
    include: 'GroupIncludeFromGroup'


class MemberIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    profile: Union[bool, 'ProfileArgsFromPost']
    group: Union[bool, 'GroupArgsFromPost']


class MemberArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'MemberIncludeFromMember'


class FindManyMemberArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMember'


class CommentIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    replies: Union[bool, 'FindManyCommentArgsFromPost']
    likes: Union[bool, 'FindManyCommentLikeArgsFromPost']
    parent: Union[bool, 'CommentArgsFromPost']
    post: Union[bool, 'PostArgsFromPost']
    profile: Union[bool, 'ProfileArgsFromPost']


class CommentArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'CommentIncludeFromComment'


class FindManyCommentArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromComment'


class PostLikeIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    post: Union[bool, 'PostArgsFromPost']
    profile: Union[bool, 'ProfileArgsFromPost']


class PostLikeArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'PostLikeIncludeFromPostLike'


class FindManyPostLikeArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['PostLikeOrderByInput', List['PostLikeOrderByInput']]
    where: 'PostLikeWhereInput'
    cursor: 'PostLikeWhereUniqueInput'
    distinct: List['PostLikeScalarFieldKeys']
    include: 'PostLikeIncludeFromPostLike'


class CommentLikeIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    comment: Union[bool, 'CommentArgsFromPost']
    profile: Union[bool, 'ProfileArgsFromPost']


class CommentLikeArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'CommentLikeIncludeFromCommentLike'


class FindManyCommentLikeArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['CommentLikeOrderByInput', List['CommentLikeOrderByInput']]
    where: 'CommentLikeWhereInput'
    cursor: 'CommentLikeWhereUniqueInput'
    distinct: List['CommentLikeScalarFieldKeys']
    include: 'CommentLikeIncludeFromCommentLike'


class RestaurantIncludeFromPost(TypedDict, total=False):
    """Relational arguments for Post"""
    posts: Union[bool, 'FindManyPostArgsFromPost']


class RestaurantArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    include: 'RestaurantIncludeFromRestaurant'


class FindManyRestaurantArgsFromPost(TypedDict, total=False):
    """Arguments for Post"""
    take: int
    skip: int
    order_by: Union['RestaurantOrderByInput', List['RestaurantOrderByInput']]
    where: 'RestaurantWhereInput'
    cursor: 'RestaurantWhereUniqueInput'
    distinct: List['RestaurantScalarFieldKeys']
    include: 'RestaurantIncludeFromRestaurant'




FindManyPostArgs = FindManyPostArgsFromPost
FindFirstPostArgs = FindManyPostArgsFromPost


class PostWhereInput(TypedDict, total=False):
    """Post arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    individual: Union[_bool, 'types.BooleanFilter']
    meal: 'enums.MealType'
    restaurant: 'RestaurantRelationFilter'
    restaurantId: Union[_str, 'types.StringFilter']
    group: 'GroupRelationFilter'
    groupId: Union[None, _str, 'types.StringFilter']
    profile: 'ProfileRelationFilter'
    profileId: Union[None, _str, 'types.StringFilter']
    comments: 'CommentListRelationFilter'
    likes: 'PostLikeListRelationFilter'
    postTags: 'PostTagListRelationFilter'
    postImages: 'PostImageListRelationFilter'
    review: Union[_str, 'types.StringFilter']
    rating: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['PostWhereInput', List['PostWhereInput']]
    # but this causes mypy to hang :/
    AND: List['PostWhereInput']
    OR: List['PostWhereInput']
    NOT: List['PostWhereInput']



# aggregate Post types


class PostScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Post arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    individual: Union[_bool, 'types.BooleanWithAggregatesFilter']
    meal: 'enums.MealType'
    restaurantId: Union[_str, 'types.StringWithAggregatesFilter']
    groupId: Union[_str, 'types.StringWithAggregatesFilter']
    profileId: Union[_str, 'types.StringWithAggregatesFilter']
    review: Union[_str, 'types.StringWithAggregatesFilter']
    rating: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PostScalarWhereWithAggregatesInput']
    OR: List['PostScalarWhereWithAggregatesInput']
    NOT: List['PostScalarWhereWithAggregatesInput']



class PostGroupByOutput(TypedDict, total=False):
    id: _str
    individual: _bool
    meal: 'enums.MealType'
    restaurantId: _str
    groupId: _str
    profileId: _str
    review: _str
    rating: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'PostSumAggregateOutput'
    _avg: 'PostAvgAggregateOutput'
    _min: 'PostMinAggregateOutput'
    _max: 'PostMaxAggregateOutput'
    _count: 'PostCountAggregateOutput'


class PostAvgAggregateOutput(TypedDict, total=False):
    """Post output for aggregating averages"""
    rating: float


class PostSumAggregateOutput(TypedDict, total=False):
    """Post output for aggregating sums"""
    rating: _int


class PostScalarAggregateOutput(TypedDict, total=False):
    """Post output including scalar fields"""
    id: _str
    individual: _bool
    meal: 'enums.MealType'
    restaurantId: _str
    groupId: _str
    profileId: _str
    review: _str
    rating: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


PostMinAggregateOutput = PostScalarAggregateOutput
PostMaxAggregateOutput = PostScalarAggregateOutput


class PostMaxAggregateInput(TypedDict, total=False):
    """Post input for aggregating by max"""
    id: bool
    individual: bool
    meal: bool
    restaurantId: bool
    groupId: bool
    profileId: bool
    review: bool
    rating: bool
    createdAt: bool
    updatedAt: bool


class PostMinAggregateInput(TypedDict, total=False):
    """Post input for aggregating by min"""
    id: bool
    individual: bool
    meal: bool
    restaurantId: bool
    groupId: bool
    profileId: bool
    review: bool
    rating: bool
    createdAt: bool
    updatedAt: bool


class PostNumberAggregateInput(TypedDict, total=False):
    """Post input for aggregating numbers"""
    rating: bool


PostAvgAggregateInput = PostNumberAggregateInput
PostSumAggregateInput = PostNumberAggregateInput


PostCountAggregateInput = TypedDict(
    'PostCountAggregateInput',
    {
        'id': bool,
        'individual': bool,
        'meal': bool,
        'restaurantId': bool,
        'groupId': bool,
        'profileId': bool,
        'review': bool,
        'rating': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

PostCountAggregateOutput = TypedDict(
    'PostCountAggregateOutput',
    {
        'id': int,
        'individual': int,
        'meal': int,
        'restaurantId': int,
        'groupId': int,
        'profileId': int,
        'review': int,
        'rating': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


PostKeys = Literal[
    'id',
    'individual',
    'meal',
    'restaurant',
    'restaurantId',
    'group',
    'groupId',
    'profile',
    'profileId',
    'comments',
    'likes',
    'postTags',
    'postImages',
    'review',
    'rating',
    'createdAt',
    'updatedAt',
]
PostScalarFieldKeys = Literal[
    'id',
    'individual',
    'meal',
    'restaurantId',
    'groupId',
    'profileId',
    'review',
    'rating',
    'createdAt',
    'updatedAt',
]
PostScalarFieldKeysT = TypeVar('PostScalarFieldKeysT', bound=PostScalarFieldKeys)

PostRelationalFieldKeys = Literal[
        'restaurant',
        'group',
        'profile',
        'comments',
        'likes',
        'postTags',
        'postImages',
    ]

# PostTag types

class PostTagOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the PostTag create method"""
    id: _str
    post: 'PostCreateNestedWithoutRelationsInput'
    postId: _str
    profile: 'ProfileCreateNestedWithoutRelationsInput'
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostTagCreateInput(PostTagOptionalCreateInput):
    """Required arguments to the PostTag create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PostTagOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the PostTag create method, without relations"""
    id: _str
    postId: _str
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostTagCreateWithoutRelationsInput(PostTagOptionalCreateWithoutRelationsInput):
    """Required arguments to the PostTag create method, without relations"""


class PostTagCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PostTagCreateWithoutRelationsInput'
    connect: 'PostTagWhereUniqueInput'


class PostTagCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PostTagCreateWithoutRelationsInput', List['PostTagCreateWithoutRelationsInput']]
    connect: Union['PostTagWhereUniqueInput', List['PostTagWhereUniqueInput']]


_PostTagWhereUnique_id_Input = TypedDict(
    '_PostTagWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

PostTagWhereUniqueInput = _PostTagWhereUnique_id_Input


class PostTagUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    post: 'PostUpdateOneWithoutRelationsInput'
    profile: 'ProfileUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostTagUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostTagUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PostTagCreateWithoutRelationsInput']
    connect: List['PostTagWhereUniqueInput']
    set: List['PostTagWhereUniqueInput']
    disconnect: List['PostTagWhereUniqueInput']
    delete: List['PostTagWhereUniqueInput']

    # TODO
    # update: List['PostTagUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PostTagUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PostTagScalarWhereInput']
    # upsert: List['PostTagUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['PostTagCreateOrConnectWithoutRelationsInput']


class PostTagUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PostTagCreateWithoutRelationsInput'
    connect: 'PostTagWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PostTagUpdateInput'
    # upsert: 'PostTagUpsertWithoutRelationsInput'
    # connectOrCreate: 'PostTagCreateOrConnectWithoutRelationsInput'


class PostTagUpsertInput(TypedDict):
    create: 'PostTagCreateInput'
    update: 'PostTagUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_PostTag_id_OrderByInput = TypedDict(
    '_PostTag_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_PostTag_postId_OrderByInput = TypedDict(
    '_PostTag_postId_OrderByInput',
    {
        'postId': 'SortOrder',
    },
    total=True
)

_PostTag_profileId_OrderByInput = TypedDict(
    '_PostTag_profileId_OrderByInput',
    {
        'profileId': 'SortOrder',
    },
    total=True
)

_PostTag_createdAt_OrderByInput = TypedDict(
    '_PostTag_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_PostTag_updatedAt_OrderByInput = TypedDict(
    '_PostTag_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

PostTagOrderByInput = Union[
    '_PostTag_id_OrderByInput',
    '_PostTag_postId_OrderByInput',
    '_PostTag_profileId_OrderByInput',
    '_PostTag_createdAt_OrderByInput',
    '_PostTag_updatedAt_OrderByInput',
]



# recursive PostTag types
# TODO: cleanup these types



PostTagRelationFilter = TypedDict(
    'PostTagRelationFilter',
    {
        'is': 'PostTagWhereInput',
        'is_not': 'PostTagWhereInput',
    },
    total=False,
)


class PostTagListRelationFilter(TypedDict, total=False):
    some: 'PostTagWhereInput'
    none: 'PostTagWhereInput'
    every: 'PostTagWhereInput'


class PostTagInclude(TypedDict, total=False):
    """PostTag relational arguments"""
    post: Union[bool, 'PostArgsFromPostTag']
    profile: Union[bool, 'ProfileArgsFromPostTag']


class ProfileIncludeFromPostTag(TypedDict, total=False):
    """Relational arguments for PostTag"""
    followsFollowing: Union[bool, 'FindManyFollowArgsFromPostTag']
    followsFollowed: Union[bool, 'FindManyFollowArgsFromPostTag']
    posts: Union[bool, 'FindManyPostArgsFromPostTag']
    postTags: Union[bool, 'FindManyPostTagArgsFromPostTag']
    members: Union[bool, 'FindManyMemberArgsFromPostTag']
    comments: Union[bool, 'FindManyCommentArgsFromPostTag']
    postLikes: Union[bool, 'FindManyPostLikeArgsFromPostTag']
    commentLikes: Union[bool, 'FindManyCommentLikeArgsFromPostTag']


class ProfileArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    include: 'ProfileIncludeFromProfile'


class FindManyProfileArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfile'


class FollowIncludeFromPostTag(TypedDict, total=False):
    """Relational arguments for PostTag"""
    following: Union[bool, 'ProfileArgsFromPostTag']
    followed: Union[bool, 'ProfileArgsFromPostTag']


class FollowArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    include: 'FollowIncludeFromFollow'


class FindManyFollowArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    take: int
    skip: int
    order_by: Union['FollowOrderByInput', List['FollowOrderByInput']]
    where: 'FollowWhereInput'
    cursor: 'FollowWhereUniqueInput'
    distinct: List['FollowScalarFieldKeys']
    include: 'FollowIncludeFromFollow'


class PostIncludeFromPostTag(TypedDict, total=False):
    """Relational arguments for PostTag"""
    restaurant: Union[bool, 'RestaurantArgsFromPostTag']
    group: Union[bool, 'GroupArgsFromPostTag']
    profile: Union[bool, 'ProfileArgsFromPostTag']
    comments: Union[bool, 'FindManyCommentArgsFromPostTag']
    likes: Union[bool, 'FindManyPostLikeArgsFromPostTag']
    postTags: Union[bool, 'FindManyPostTagArgsFromPostTag']
    postImages: Union[bool, 'FindManyPostImageArgsFromPostTag']


class PostArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    include: 'PostIncludeFromPost'


class FindManyPostArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPost'


class PostTagIncludeFromPostTag(TypedDict, total=False):
    """Relational arguments for PostTag"""
    post: Union[bool, 'PostArgsFromPostTag']
    profile: Union[bool, 'ProfileArgsFromPostTag']


class PostTagArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    include: 'PostTagIncludeFromPostTag'


class FindManyPostTagArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    take: int
    skip: int
    order_by: Union['PostTagOrderByInput', List['PostTagOrderByInput']]
    where: 'PostTagWhereInput'
    cursor: 'PostTagWhereUniqueInput'
    distinct: List['PostTagScalarFieldKeys']
    include: 'PostTagIncludeFromPostTag'


class PostImageIncludeFromPostTag(TypedDict, total=False):
    """Relational arguments for PostTag"""
    post: Union[bool, 'PostArgsFromPostTag']


class PostImageArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    include: 'PostImageIncludeFromPostImage'


class FindManyPostImageArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    take: int
    skip: int
    order_by: Union['PostImageOrderByInput', List['PostImageOrderByInput']]
    where: 'PostImageWhereInput'
    cursor: 'PostImageWhereUniqueInput'
    distinct: List['PostImageScalarFieldKeys']
    include: 'PostImageIncludeFromPostImage'


class GroupIncludeFromPostTag(TypedDict, total=False):
    """Relational arguments for PostTag"""
    members: Union[bool, 'FindManyMemberArgsFromPostTag']
    posts: Union[bool, 'FindManyPostArgsFromPostTag']


class GroupArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    include: 'GroupIncludeFromGroup'


class FindManyGroupArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    take: int
    skip: int
    order_by: Union['GroupOrderByInput', List['GroupOrderByInput']]
    where: 'GroupWhereInput'
    cursor: 'GroupWhereUniqueInput'
    distinct: List['GroupScalarFieldKeys']
    include: 'GroupIncludeFromGroup'


class MemberIncludeFromPostTag(TypedDict, total=False):
    """Relational arguments for PostTag"""
    profile: Union[bool, 'ProfileArgsFromPostTag']
    group: Union[bool, 'GroupArgsFromPostTag']


class MemberArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    include: 'MemberIncludeFromMember'


class FindManyMemberArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMember'


class CommentIncludeFromPostTag(TypedDict, total=False):
    """Relational arguments for PostTag"""
    replies: Union[bool, 'FindManyCommentArgsFromPostTag']
    likes: Union[bool, 'FindManyCommentLikeArgsFromPostTag']
    parent: Union[bool, 'CommentArgsFromPostTag']
    post: Union[bool, 'PostArgsFromPostTag']
    profile: Union[bool, 'ProfileArgsFromPostTag']


class CommentArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    include: 'CommentIncludeFromComment'


class FindManyCommentArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromComment'


class PostLikeIncludeFromPostTag(TypedDict, total=False):
    """Relational arguments for PostTag"""
    post: Union[bool, 'PostArgsFromPostTag']
    profile: Union[bool, 'ProfileArgsFromPostTag']


class PostLikeArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    include: 'PostLikeIncludeFromPostLike'


class FindManyPostLikeArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    take: int
    skip: int
    order_by: Union['PostLikeOrderByInput', List['PostLikeOrderByInput']]
    where: 'PostLikeWhereInput'
    cursor: 'PostLikeWhereUniqueInput'
    distinct: List['PostLikeScalarFieldKeys']
    include: 'PostLikeIncludeFromPostLike'


class CommentLikeIncludeFromPostTag(TypedDict, total=False):
    """Relational arguments for PostTag"""
    comment: Union[bool, 'CommentArgsFromPostTag']
    profile: Union[bool, 'ProfileArgsFromPostTag']


class CommentLikeArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    include: 'CommentLikeIncludeFromCommentLike'


class FindManyCommentLikeArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    take: int
    skip: int
    order_by: Union['CommentLikeOrderByInput', List['CommentLikeOrderByInput']]
    where: 'CommentLikeWhereInput'
    cursor: 'CommentLikeWhereUniqueInput'
    distinct: List['CommentLikeScalarFieldKeys']
    include: 'CommentLikeIncludeFromCommentLike'


class RestaurantIncludeFromPostTag(TypedDict, total=False):
    """Relational arguments for PostTag"""
    posts: Union[bool, 'FindManyPostArgsFromPostTag']


class RestaurantArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    include: 'RestaurantIncludeFromRestaurant'


class FindManyRestaurantArgsFromPostTag(TypedDict, total=False):
    """Arguments for PostTag"""
    take: int
    skip: int
    order_by: Union['RestaurantOrderByInput', List['RestaurantOrderByInput']]
    where: 'RestaurantWhereInput'
    cursor: 'RestaurantWhereUniqueInput'
    distinct: List['RestaurantScalarFieldKeys']
    include: 'RestaurantIncludeFromRestaurant'




FindManyPostTagArgs = FindManyPostTagArgsFromPostTag
FindFirstPostTagArgs = FindManyPostTagArgsFromPostTag


class PostTagWhereInput(TypedDict, total=False):
    """PostTag arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    post: 'PostRelationFilter'
    postId: Union[_str, 'types.StringFilter']
    profile: 'ProfileRelationFilter'
    profileId: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['PostTagWhereInput', List['PostTagWhereInput']]
    # but this causes mypy to hang :/
    AND: List['PostTagWhereInput']
    OR: List['PostTagWhereInput']
    NOT: List['PostTagWhereInput']



# aggregate PostTag types


class PostTagScalarWhereWithAggregatesInput(TypedDict, total=False):
    """PostTag arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    postId: Union[_str, 'types.StringWithAggregatesFilter']
    profileId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PostTagScalarWhereWithAggregatesInput']
    OR: List['PostTagScalarWhereWithAggregatesInput']
    NOT: List['PostTagScalarWhereWithAggregatesInput']



class PostTagGroupByOutput(TypedDict, total=False):
    id: _str
    postId: _str
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'PostTagSumAggregateOutput'
    _avg: 'PostTagAvgAggregateOutput'
    _min: 'PostTagMinAggregateOutput'
    _max: 'PostTagMaxAggregateOutput'
    _count: 'PostTagCountAggregateOutput'


class PostTagAvgAggregateOutput(TypedDict, total=False):
    """PostTag output for aggregating averages"""


class PostTagSumAggregateOutput(TypedDict, total=False):
    """PostTag output for aggregating sums"""


class PostTagScalarAggregateOutput(TypedDict, total=False):
    """PostTag output including scalar fields"""
    id: _str
    postId: _str
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


PostTagMinAggregateOutput = PostTagScalarAggregateOutput
PostTagMaxAggregateOutput = PostTagScalarAggregateOutput


class PostTagMaxAggregateInput(TypedDict, total=False):
    """PostTag input for aggregating by max"""
    id: bool
    postId: bool
    profileId: bool
    createdAt: bool
    updatedAt: bool


class PostTagMinAggregateInput(TypedDict, total=False):
    """PostTag input for aggregating by min"""
    id: bool
    postId: bool
    profileId: bool
    createdAt: bool
    updatedAt: bool


class PostTagNumberAggregateInput(TypedDict, total=False):
    """PostTag input for aggregating numbers"""


PostTagAvgAggregateInput = PostTagNumberAggregateInput
PostTagSumAggregateInput = PostTagNumberAggregateInput


PostTagCountAggregateInput = TypedDict(
    'PostTagCountAggregateInput',
    {
        'id': bool,
        'postId': bool,
        'profileId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

PostTagCountAggregateOutput = TypedDict(
    'PostTagCountAggregateOutput',
    {
        'id': int,
        'postId': int,
        'profileId': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


PostTagKeys = Literal[
    'id',
    'post',
    'postId',
    'profile',
    'profileId',
    'createdAt',
    'updatedAt',
]
PostTagScalarFieldKeys = Literal[
    'id',
    'postId',
    'profileId',
    'createdAt',
    'updatedAt',
]
PostTagScalarFieldKeysT = TypeVar('PostTagScalarFieldKeysT', bound=PostTagScalarFieldKeys)

PostTagRelationalFieldKeys = Literal[
        'post',
        'profile',
    ]

# PostImage types

class PostImageOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the PostImage create method"""
    id: _str
    post: 'PostCreateNestedWithoutRelationsInput'
    postId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostImageCreateInput(PostImageOptionalCreateInput):
    """Required arguments to the PostImage create method"""
    imageUrl: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PostImageOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the PostImage create method, without relations"""
    id: _str
    postId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostImageCreateWithoutRelationsInput(PostImageOptionalCreateWithoutRelationsInput):
    """Required arguments to the PostImage create method, without relations"""
    imageUrl: _str


class PostImageCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PostImageCreateWithoutRelationsInput'
    connect: 'PostImageWhereUniqueInput'


class PostImageCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PostImageCreateWithoutRelationsInput', List['PostImageCreateWithoutRelationsInput']]
    connect: Union['PostImageWhereUniqueInput', List['PostImageWhereUniqueInput']]


_PostImageWhereUnique_id_Input = TypedDict(
    '_PostImageWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

PostImageWhereUniqueInput = _PostImageWhereUnique_id_Input


class PostImageUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    post: 'PostUpdateOneWithoutRelationsInput'
    imageUrl: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostImageUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    imageUrl: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostImageUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PostImageCreateWithoutRelationsInput']
    connect: List['PostImageWhereUniqueInput']
    set: List['PostImageWhereUniqueInput']
    disconnect: List['PostImageWhereUniqueInput']
    delete: List['PostImageWhereUniqueInput']

    # TODO
    # update: List['PostImageUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PostImageUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PostImageScalarWhereInput']
    # upsert: List['PostImageUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['PostImageCreateOrConnectWithoutRelationsInput']


class PostImageUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PostImageCreateWithoutRelationsInput'
    connect: 'PostImageWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PostImageUpdateInput'
    # upsert: 'PostImageUpsertWithoutRelationsInput'
    # connectOrCreate: 'PostImageCreateOrConnectWithoutRelationsInput'


class PostImageUpsertInput(TypedDict):
    create: 'PostImageCreateInput'
    update: 'PostImageUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_PostImage_id_OrderByInput = TypedDict(
    '_PostImage_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_PostImage_postId_OrderByInput = TypedDict(
    '_PostImage_postId_OrderByInput',
    {
        'postId': 'SortOrder',
    },
    total=True
)

_PostImage_imageUrl_OrderByInput = TypedDict(
    '_PostImage_imageUrl_OrderByInput',
    {
        'imageUrl': 'SortOrder',
    },
    total=True
)

_PostImage_createdAt_OrderByInput = TypedDict(
    '_PostImage_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_PostImage_updatedAt_OrderByInput = TypedDict(
    '_PostImage_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

PostImageOrderByInput = Union[
    '_PostImage_id_OrderByInput',
    '_PostImage_postId_OrderByInput',
    '_PostImage_imageUrl_OrderByInput',
    '_PostImage_createdAt_OrderByInput',
    '_PostImage_updatedAt_OrderByInput',
]



# recursive PostImage types
# TODO: cleanup these types



PostImageRelationFilter = TypedDict(
    'PostImageRelationFilter',
    {
        'is': 'PostImageWhereInput',
        'is_not': 'PostImageWhereInput',
    },
    total=False,
)


class PostImageListRelationFilter(TypedDict, total=False):
    some: 'PostImageWhereInput'
    none: 'PostImageWhereInput'
    every: 'PostImageWhereInput'


class PostImageInclude(TypedDict, total=False):
    """PostImage relational arguments"""
    post: Union[bool, 'PostArgsFromPostImage']


class ProfileIncludeFromPostImage(TypedDict, total=False):
    """Relational arguments for PostImage"""
    followsFollowing: Union[bool, 'FindManyFollowArgsFromPostImage']
    followsFollowed: Union[bool, 'FindManyFollowArgsFromPostImage']
    posts: Union[bool, 'FindManyPostArgsFromPostImage']
    postTags: Union[bool, 'FindManyPostTagArgsFromPostImage']
    members: Union[bool, 'FindManyMemberArgsFromPostImage']
    comments: Union[bool, 'FindManyCommentArgsFromPostImage']
    postLikes: Union[bool, 'FindManyPostLikeArgsFromPostImage']
    commentLikes: Union[bool, 'FindManyCommentLikeArgsFromPostImage']


class ProfileArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    include: 'ProfileIncludeFromProfile'


class FindManyProfileArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfile'


class FollowIncludeFromPostImage(TypedDict, total=False):
    """Relational arguments for PostImage"""
    following: Union[bool, 'ProfileArgsFromPostImage']
    followed: Union[bool, 'ProfileArgsFromPostImage']


class FollowArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    include: 'FollowIncludeFromFollow'


class FindManyFollowArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    take: int
    skip: int
    order_by: Union['FollowOrderByInput', List['FollowOrderByInput']]
    where: 'FollowWhereInput'
    cursor: 'FollowWhereUniqueInput'
    distinct: List['FollowScalarFieldKeys']
    include: 'FollowIncludeFromFollow'


class PostIncludeFromPostImage(TypedDict, total=False):
    """Relational arguments for PostImage"""
    restaurant: Union[bool, 'RestaurantArgsFromPostImage']
    group: Union[bool, 'GroupArgsFromPostImage']
    profile: Union[bool, 'ProfileArgsFromPostImage']
    comments: Union[bool, 'FindManyCommentArgsFromPostImage']
    likes: Union[bool, 'FindManyPostLikeArgsFromPostImage']
    postTags: Union[bool, 'FindManyPostTagArgsFromPostImage']
    postImages: Union[bool, 'FindManyPostImageArgsFromPostImage']


class PostArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    include: 'PostIncludeFromPost'


class FindManyPostArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPost'


class PostTagIncludeFromPostImage(TypedDict, total=False):
    """Relational arguments for PostImage"""
    post: Union[bool, 'PostArgsFromPostImage']
    profile: Union[bool, 'ProfileArgsFromPostImage']


class PostTagArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    include: 'PostTagIncludeFromPostTag'


class FindManyPostTagArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    take: int
    skip: int
    order_by: Union['PostTagOrderByInput', List['PostTagOrderByInput']]
    where: 'PostTagWhereInput'
    cursor: 'PostTagWhereUniqueInput'
    distinct: List['PostTagScalarFieldKeys']
    include: 'PostTagIncludeFromPostTag'


class PostImageIncludeFromPostImage(TypedDict, total=False):
    """Relational arguments for PostImage"""
    post: Union[bool, 'PostArgsFromPostImage']


class PostImageArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    include: 'PostImageIncludeFromPostImage'


class FindManyPostImageArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    take: int
    skip: int
    order_by: Union['PostImageOrderByInput', List['PostImageOrderByInput']]
    where: 'PostImageWhereInput'
    cursor: 'PostImageWhereUniqueInput'
    distinct: List['PostImageScalarFieldKeys']
    include: 'PostImageIncludeFromPostImage'


class GroupIncludeFromPostImage(TypedDict, total=False):
    """Relational arguments for PostImage"""
    members: Union[bool, 'FindManyMemberArgsFromPostImage']
    posts: Union[bool, 'FindManyPostArgsFromPostImage']


class GroupArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    include: 'GroupIncludeFromGroup'


class FindManyGroupArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    take: int
    skip: int
    order_by: Union['GroupOrderByInput', List['GroupOrderByInput']]
    where: 'GroupWhereInput'
    cursor: 'GroupWhereUniqueInput'
    distinct: List['GroupScalarFieldKeys']
    include: 'GroupIncludeFromGroup'


class MemberIncludeFromPostImage(TypedDict, total=False):
    """Relational arguments for PostImage"""
    profile: Union[bool, 'ProfileArgsFromPostImage']
    group: Union[bool, 'GroupArgsFromPostImage']


class MemberArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    include: 'MemberIncludeFromMember'


class FindManyMemberArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMember'


class CommentIncludeFromPostImage(TypedDict, total=False):
    """Relational arguments for PostImage"""
    replies: Union[bool, 'FindManyCommentArgsFromPostImage']
    likes: Union[bool, 'FindManyCommentLikeArgsFromPostImage']
    parent: Union[bool, 'CommentArgsFromPostImage']
    post: Union[bool, 'PostArgsFromPostImage']
    profile: Union[bool, 'ProfileArgsFromPostImage']


class CommentArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    include: 'CommentIncludeFromComment'


class FindManyCommentArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromComment'


class PostLikeIncludeFromPostImage(TypedDict, total=False):
    """Relational arguments for PostImage"""
    post: Union[bool, 'PostArgsFromPostImage']
    profile: Union[bool, 'ProfileArgsFromPostImage']


class PostLikeArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    include: 'PostLikeIncludeFromPostLike'


class FindManyPostLikeArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    take: int
    skip: int
    order_by: Union['PostLikeOrderByInput', List['PostLikeOrderByInput']]
    where: 'PostLikeWhereInput'
    cursor: 'PostLikeWhereUniqueInput'
    distinct: List['PostLikeScalarFieldKeys']
    include: 'PostLikeIncludeFromPostLike'


class CommentLikeIncludeFromPostImage(TypedDict, total=False):
    """Relational arguments for PostImage"""
    comment: Union[bool, 'CommentArgsFromPostImage']
    profile: Union[bool, 'ProfileArgsFromPostImage']


class CommentLikeArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    include: 'CommentLikeIncludeFromCommentLike'


class FindManyCommentLikeArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    take: int
    skip: int
    order_by: Union['CommentLikeOrderByInput', List['CommentLikeOrderByInput']]
    where: 'CommentLikeWhereInput'
    cursor: 'CommentLikeWhereUniqueInput'
    distinct: List['CommentLikeScalarFieldKeys']
    include: 'CommentLikeIncludeFromCommentLike'


class RestaurantIncludeFromPostImage(TypedDict, total=False):
    """Relational arguments for PostImage"""
    posts: Union[bool, 'FindManyPostArgsFromPostImage']


class RestaurantArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    include: 'RestaurantIncludeFromRestaurant'


class FindManyRestaurantArgsFromPostImage(TypedDict, total=False):
    """Arguments for PostImage"""
    take: int
    skip: int
    order_by: Union['RestaurantOrderByInput', List['RestaurantOrderByInput']]
    where: 'RestaurantWhereInput'
    cursor: 'RestaurantWhereUniqueInput'
    distinct: List['RestaurantScalarFieldKeys']
    include: 'RestaurantIncludeFromRestaurant'




FindManyPostImageArgs = FindManyPostImageArgsFromPostImage
FindFirstPostImageArgs = FindManyPostImageArgsFromPostImage


class PostImageWhereInput(TypedDict, total=False):
    """PostImage arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    post: 'PostRelationFilter'
    postId: Union[_str, 'types.StringFilter']
    imageUrl: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['PostImageWhereInput', List['PostImageWhereInput']]
    # but this causes mypy to hang :/
    AND: List['PostImageWhereInput']
    OR: List['PostImageWhereInput']
    NOT: List['PostImageWhereInput']



# aggregate PostImage types


class PostImageScalarWhereWithAggregatesInput(TypedDict, total=False):
    """PostImage arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    postId: Union[_str, 'types.StringWithAggregatesFilter']
    imageUrl: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PostImageScalarWhereWithAggregatesInput']
    OR: List['PostImageScalarWhereWithAggregatesInput']
    NOT: List['PostImageScalarWhereWithAggregatesInput']



class PostImageGroupByOutput(TypedDict, total=False):
    id: _str
    postId: _str
    imageUrl: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'PostImageSumAggregateOutput'
    _avg: 'PostImageAvgAggregateOutput'
    _min: 'PostImageMinAggregateOutput'
    _max: 'PostImageMaxAggregateOutput'
    _count: 'PostImageCountAggregateOutput'


class PostImageAvgAggregateOutput(TypedDict, total=False):
    """PostImage output for aggregating averages"""


class PostImageSumAggregateOutput(TypedDict, total=False):
    """PostImage output for aggregating sums"""


class PostImageScalarAggregateOutput(TypedDict, total=False):
    """PostImage output including scalar fields"""
    id: _str
    postId: _str
    imageUrl: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


PostImageMinAggregateOutput = PostImageScalarAggregateOutput
PostImageMaxAggregateOutput = PostImageScalarAggregateOutput


class PostImageMaxAggregateInput(TypedDict, total=False):
    """PostImage input for aggregating by max"""
    id: bool
    postId: bool
    imageUrl: bool
    createdAt: bool
    updatedAt: bool


class PostImageMinAggregateInput(TypedDict, total=False):
    """PostImage input for aggregating by min"""
    id: bool
    postId: bool
    imageUrl: bool
    createdAt: bool
    updatedAt: bool


class PostImageNumberAggregateInput(TypedDict, total=False):
    """PostImage input for aggregating numbers"""


PostImageAvgAggregateInput = PostImageNumberAggregateInput
PostImageSumAggregateInput = PostImageNumberAggregateInput


PostImageCountAggregateInput = TypedDict(
    'PostImageCountAggregateInput',
    {
        'id': bool,
        'postId': bool,
        'imageUrl': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

PostImageCountAggregateOutput = TypedDict(
    'PostImageCountAggregateOutput',
    {
        'id': int,
        'postId': int,
        'imageUrl': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


PostImageKeys = Literal[
    'id',
    'post',
    'postId',
    'imageUrl',
    'createdAt',
    'updatedAt',
]
PostImageScalarFieldKeys = Literal[
    'id',
    'postId',
    'imageUrl',
    'createdAt',
    'updatedAt',
]
PostImageScalarFieldKeysT = TypeVar('PostImageScalarFieldKeysT', bound=PostImageScalarFieldKeys)

PostImageRelationalFieldKeys = Literal[
        'post',
    ]

# Group types

class GroupOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Group create method"""
    id: _str
    members: 'MemberCreateManyNestedWithoutRelationsInput'
    posts: 'PostCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class GroupCreateInput(GroupOptionalCreateInput):
    """Required arguments to the Group create method"""
    name: _str
    description: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class GroupOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Group create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class GroupCreateWithoutRelationsInput(GroupOptionalCreateWithoutRelationsInput):
    """Required arguments to the Group create method, without relations"""
    name: _str
    description: _str


class GroupCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'GroupCreateWithoutRelationsInput'
    connect: 'GroupWhereUniqueInput'


class GroupCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['GroupCreateWithoutRelationsInput', List['GroupCreateWithoutRelationsInput']]
    connect: Union['GroupWhereUniqueInput', List['GroupWhereUniqueInput']]


_GroupWhereUnique_id_Input = TypedDict(
    '_GroupWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

GroupWhereUniqueInput = _GroupWhereUnique_id_Input


class GroupUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    description: _str
    members: 'MemberUpdateManyWithoutRelationsInput'
    posts: 'PostUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class GroupUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    description: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class GroupUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['GroupCreateWithoutRelationsInput']
    connect: List['GroupWhereUniqueInput']
    set: List['GroupWhereUniqueInput']
    disconnect: List['GroupWhereUniqueInput']
    delete: List['GroupWhereUniqueInput']

    # TODO
    # update: List['GroupUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['GroupUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['GroupScalarWhereInput']
    # upsert: List['GroupUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['GroupCreateOrConnectWithoutRelationsInput']


class GroupUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'GroupCreateWithoutRelationsInput'
    connect: 'GroupWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'GroupUpdateInput'
    # upsert: 'GroupUpsertWithoutRelationsInput'
    # connectOrCreate: 'GroupCreateOrConnectWithoutRelationsInput'


class GroupUpsertInput(TypedDict):
    create: 'GroupCreateInput'
    update: 'GroupUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Group_id_OrderByInput = TypedDict(
    '_Group_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Group_name_OrderByInput = TypedDict(
    '_Group_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Group_description_OrderByInput = TypedDict(
    '_Group_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Group_createdAt_OrderByInput = TypedDict(
    '_Group_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Group_updatedAt_OrderByInput = TypedDict(
    '_Group_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

GroupOrderByInput = Union[
    '_Group_id_OrderByInput',
    '_Group_name_OrderByInput',
    '_Group_description_OrderByInput',
    '_Group_createdAt_OrderByInput',
    '_Group_updatedAt_OrderByInput',
]



# recursive Group types
# TODO: cleanup these types



GroupRelationFilter = TypedDict(
    'GroupRelationFilter',
    {
        'is': 'GroupWhereInput',
        'is_not': 'GroupWhereInput',
    },
    total=False,
)


class GroupListRelationFilter(TypedDict, total=False):
    some: 'GroupWhereInput'
    none: 'GroupWhereInput'
    every: 'GroupWhereInput'


class GroupInclude(TypedDict, total=False):
    """Group relational arguments"""
    members: Union[bool, 'FindManyMemberArgsFromGroup']
    posts: Union[bool, 'FindManyPostArgsFromGroup']


class ProfileIncludeFromGroup(TypedDict, total=False):
    """Relational arguments for Group"""
    followsFollowing: Union[bool, 'FindManyFollowArgsFromGroup']
    followsFollowed: Union[bool, 'FindManyFollowArgsFromGroup']
    posts: Union[bool, 'FindManyPostArgsFromGroup']
    postTags: Union[bool, 'FindManyPostTagArgsFromGroup']
    members: Union[bool, 'FindManyMemberArgsFromGroup']
    comments: Union[bool, 'FindManyCommentArgsFromGroup']
    postLikes: Union[bool, 'FindManyPostLikeArgsFromGroup']
    commentLikes: Union[bool, 'FindManyCommentLikeArgsFromGroup']


class ProfileArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    include: 'ProfileIncludeFromProfile'


class FindManyProfileArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfile'


class FollowIncludeFromGroup(TypedDict, total=False):
    """Relational arguments for Group"""
    following: Union[bool, 'ProfileArgsFromGroup']
    followed: Union[bool, 'ProfileArgsFromGroup']


class FollowArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    include: 'FollowIncludeFromFollow'


class FindManyFollowArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    take: int
    skip: int
    order_by: Union['FollowOrderByInput', List['FollowOrderByInput']]
    where: 'FollowWhereInput'
    cursor: 'FollowWhereUniqueInput'
    distinct: List['FollowScalarFieldKeys']
    include: 'FollowIncludeFromFollow'


class PostIncludeFromGroup(TypedDict, total=False):
    """Relational arguments for Group"""
    restaurant: Union[bool, 'RestaurantArgsFromGroup']
    group: Union[bool, 'GroupArgsFromGroup']
    profile: Union[bool, 'ProfileArgsFromGroup']
    comments: Union[bool, 'FindManyCommentArgsFromGroup']
    likes: Union[bool, 'FindManyPostLikeArgsFromGroup']
    postTags: Union[bool, 'FindManyPostTagArgsFromGroup']
    postImages: Union[bool, 'FindManyPostImageArgsFromGroup']


class PostArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    include: 'PostIncludeFromPost'


class FindManyPostArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPost'


class PostTagIncludeFromGroup(TypedDict, total=False):
    """Relational arguments for Group"""
    post: Union[bool, 'PostArgsFromGroup']
    profile: Union[bool, 'ProfileArgsFromGroup']


class PostTagArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    include: 'PostTagIncludeFromPostTag'


class FindManyPostTagArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    take: int
    skip: int
    order_by: Union['PostTagOrderByInput', List['PostTagOrderByInput']]
    where: 'PostTagWhereInput'
    cursor: 'PostTagWhereUniqueInput'
    distinct: List['PostTagScalarFieldKeys']
    include: 'PostTagIncludeFromPostTag'


class PostImageIncludeFromGroup(TypedDict, total=False):
    """Relational arguments for Group"""
    post: Union[bool, 'PostArgsFromGroup']


class PostImageArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    include: 'PostImageIncludeFromPostImage'


class FindManyPostImageArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    take: int
    skip: int
    order_by: Union['PostImageOrderByInput', List['PostImageOrderByInput']]
    where: 'PostImageWhereInput'
    cursor: 'PostImageWhereUniqueInput'
    distinct: List['PostImageScalarFieldKeys']
    include: 'PostImageIncludeFromPostImage'


class GroupIncludeFromGroup(TypedDict, total=False):
    """Relational arguments for Group"""
    members: Union[bool, 'FindManyMemberArgsFromGroup']
    posts: Union[bool, 'FindManyPostArgsFromGroup']


class GroupArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    include: 'GroupIncludeFromGroup'


class FindManyGroupArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    take: int
    skip: int
    order_by: Union['GroupOrderByInput', List['GroupOrderByInput']]
    where: 'GroupWhereInput'
    cursor: 'GroupWhereUniqueInput'
    distinct: List['GroupScalarFieldKeys']
    include: 'GroupIncludeFromGroup'


class MemberIncludeFromGroup(TypedDict, total=False):
    """Relational arguments for Group"""
    profile: Union[bool, 'ProfileArgsFromGroup']
    group: Union[bool, 'GroupArgsFromGroup']


class MemberArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    include: 'MemberIncludeFromMember'


class FindManyMemberArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMember'


class CommentIncludeFromGroup(TypedDict, total=False):
    """Relational arguments for Group"""
    replies: Union[bool, 'FindManyCommentArgsFromGroup']
    likes: Union[bool, 'FindManyCommentLikeArgsFromGroup']
    parent: Union[bool, 'CommentArgsFromGroup']
    post: Union[bool, 'PostArgsFromGroup']
    profile: Union[bool, 'ProfileArgsFromGroup']


class CommentArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    include: 'CommentIncludeFromComment'


class FindManyCommentArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromComment'


class PostLikeIncludeFromGroup(TypedDict, total=False):
    """Relational arguments for Group"""
    post: Union[bool, 'PostArgsFromGroup']
    profile: Union[bool, 'ProfileArgsFromGroup']


class PostLikeArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    include: 'PostLikeIncludeFromPostLike'


class FindManyPostLikeArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    take: int
    skip: int
    order_by: Union['PostLikeOrderByInput', List['PostLikeOrderByInput']]
    where: 'PostLikeWhereInput'
    cursor: 'PostLikeWhereUniqueInput'
    distinct: List['PostLikeScalarFieldKeys']
    include: 'PostLikeIncludeFromPostLike'


class CommentLikeIncludeFromGroup(TypedDict, total=False):
    """Relational arguments for Group"""
    comment: Union[bool, 'CommentArgsFromGroup']
    profile: Union[bool, 'ProfileArgsFromGroup']


class CommentLikeArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    include: 'CommentLikeIncludeFromCommentLike'


class FindManyCommentLikeArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    take: int
    skip: int
    order_by: Union['CommentLikeOrderByInput', List['CommentLikeOrderByInput']]
    where: 'CommentLikeWhereInput'
    cursor: 'CommentLikeWhereUniqueInput'
    distinct: List['CommentLikeScalarFieldKeys']
    include: 'CommentLikeIncludeFromCommentLike'


class RestaurantIncludeFromGroup(TypedDict, total=False):
    """Relational arguments for Group"""
    posts: Union[bool, 'FindManyPostArgsFromGroup']


class RestaurantArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    include: 'RestaurantIncludeFromRestaurant'


class FindManyRestaurantArgsFromGroup(TypedDict, total=False):
    """Arguments for Group"""
    take: int
    skip: int
    order_by: Union['RestaurantOrderByInput', List['RestaurantOrderByInput']]
    where: 'RestaurantWhereInput'
    cursor: 'RestaurantWhereUniqueInput'
    distinct: List['RestaurantScalarFieldKeys']
    include: 'RestaurantIncludeFromRestaurant'




FindManyGroupArgs = FindManyGroupArgsFromGroup
FindFirstGroupArgs = FindManyGroupArgsFromGroup


class GroupWhereInput(TypedDict, total=False):
    """Group arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[_str, 'types.StringFilter']
    members: 'MemberListRelationFilter'
    posts: 'PostListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['GroupWhereInput', List['GroupWhereInput']]
    # but this causes mypy to hang :/
    AND: List['GroupWhereInput']
    OR: List['GroupWhereInput']
    NOT: List['GroupWhereInput']



# aggregate Group types


class GroupScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Group arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['GroupScalarWhereWithAggregatesInput']
    OR: List['GroupScalarWhereWithAggregatesInput']
    NOT: List['GroupScalarWhereWithAggregatesInput']



class GroupGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    description: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'GroupSumAggregateOutput'
    _avg: 'GroupAvgAggregateOutput'
    _min: 'GroupMinAggregateOutput'
    _max: 'GroupMaxAggregateOutput'
    _count: 'GroupCountAggregateOutput'


class GroupAvgAggregateOutput(TypedDict, total=False):
    """Group output for aggregating averages"""


class GroupSumAggregateOutput(TypedDict, total=False):
    """Group output for aggregating sums"""


class GroupScalarAggregateOutput(TypedDict, total=False):
    """Group output including scalar fields"""
    id: _str
    name: _str
    description: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


GroupMinAggregateOutput = GroupScalarAggregateOutput
GroupMaxAggregateOutput = GroupScalarAggregateOutput


class GroupMaxAggregateInput(TypedDict, total=False):
    """Group input for aggregating by max"""
    id: bool
    name: bool
    description: bool
    createdAt: bool
    updatedAt: bool


class GroupMinAggregateInput(TypedDict, total=False):
    """Group input for aggregating by min"""
    id: bool
    name: bool
    description: bool
    createdAt: bool
    updatedAt: bool


class GroupNumberAggregateInput(TypedDict, total=False):
    """Group input for aggregating numbers"""


GroupAvgAggregateInput = GroupNumberAggregateInput
GroupSumAggregateInput = GroupNumberAggregateInput


GroupCountAggregateInput = TypedDict(
    'GroupCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'description': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

GroupCountAggregateOutput = TypedDict(
    'GroupCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'description': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


GroupKeys = Literal[
    'id',
    'name',
    'description',
    'members',
    'posts',
    'createdAt',
    'updatedAt',
]
GroupScalarFieldKeys = Literal[
    'id',
    'name',
    'description',
    'createdAt',
    'updatedAt',
]
GroupScalarFieldKeysT = TypeVar('GroupScalarFieldKeysT', bound=GroupScalarFieldKeys)

GroupRelationalFieldKeys = Literal[
        'members',
        'posts',
    ]

# Member types

class MemberOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Member create method"""
    id: _str
    profile: 'ProfileCreateNestedWithoutRelationsInput'
    profileId: _str
    group: 'GroupCreateNestedWithoutRelationsInput'
    groupId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class MemberCreateInput(MemberOptionalCreateInput):
    """Required arguments to the Member create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MemberOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Member create method, without relations"""
    id: _str
    profileId: _str
    groupId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class MemberCreateWithoutRelationsInput(MemberOptionalCreateWithoutRelationsInput):
    """Required arguments to the Member create method, without relations"""


class MemberCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MemberCreateWithoutRelationsInput'
    connect: 'MemberWhereUniqueInput'


class MemberCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MemberCreateWithoutRelationsInput', List['MemberCreateWithoutRelationsInput']]
    connect: Union['MemberWhereUniqueInput', List['MemberWhereUniqueInput']]


_MemberWhereUnique_id_Input = TypedDict(
    '_MemberWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

MemberWhereUniqueInput = _MemberWhereUnique_id_Input


class MemberUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    profile: 'ProfileUpdateOneWithoutRelationsInput'
    group: 'GroupUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class MemberUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class MemberUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MemberCreateWithoutRelationsInput']
    connect: List['MemberWhereUniqueInput']
    set: List['MemberWhereUniqueInput']
    disconnect: List['MemberWhereUniqueInput']
    delete: List['MemberWhereUniqueInput']

    # TODO
    # update: List['MemberUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MemberUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MemberScalarWhereInput']
    # upsert: List['MemberUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['MemberCreateOrConnectWithoutRelationsInput']


class MemberUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MemberCreateWithoutRelationsInput'
    connect: 'MemberWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MemberUpdateInput'
    # upsert: 'MemberUpsertWithoutRelationsInput'
    # connectOrCreate: 'MemberCreateOrConnectWithoutRelationsInput'


class MemberUpsertInput(TypedDict):
    create: 'MemberCreateInput'
    update: 'MemberUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Member_id_OrderByInput = TypedDict(
    '_Member_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Member_profileId_OrderByInput = TypedDict(
    '_Member_profileId_OrderByInput',
    {
        'profileId': 'SortOrder',
    },
    total=True
)

_Member_groupId_OrderByInput = TypedDict(
    '_Member_groupId_OrderByInput',
    {
        'groupId': 'SortOrder',
    },
    total=True
)

_Member_createdAt_OrderByInput = TypedDict(
    '_Member_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Member_updatedAt_OrderByInput = TypedDict(
    '_Member_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

MemberOrderByInput = Union[
    '_Member_id_OrderByInput',
    '_Member_profileId_OrderByInput',
    '_Member_groupId_OrderByInput',
    '_Member_createdAt_OrderByInput',
    '_Member_updatedAt_OrderByInput',
]



# recursive Member types
# TODO: cleanup these types



MemberRelationFilter = TypedDict(
    'MemberRelationFilter',
    {
        'is': 'MemberWhereInput',
        'is_not': 'MemberWhereInput',
    },
    total=False,
)


class MemberListRelationFilter(TypedDict, total=False):
    some: 'MemberWhereInput'
    none: 'MemberWhereInput'
    every: 'MemberWhereInput'


class MemberInclude(TypedDict, total=False):
    """Member relational arguments"""
    profile: Union[bool, 'ProfileArgsFromMember']
    group: Union[bool, 'GroupArgsFromMember']


class ProfileIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    followsFollowing: Union[bool, 'FindManyFollowArgsFromMember']
    followsFollowed: Union[bool, 'FindManyFollowArgsFromMember']
    posts: Union[bool, 'FindManyPostArgsFromMember']
    postTags: Union[bool, 'FindManyPostTagArgsFromMember']
    members: Union[bool, 'FindManyMemberArgsFromMember']
    comments: Union[bool, 'FindManyCommentArgsFromMember']
    postLikes: Union[bool, 'FindManyPostLikeArgsFromMember']
    commentLikes: Union[bool, 'FindManyCommentLikeArgsFromMember']


class ProfileArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'ProfileIncludeFromProfile'


class FindManyProfileArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfile'


class FollowIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    following: Union[bool, 'ProfileArgsFromMember']
    followed: Union[bool, 'ProfileArgsFromMember']


class FollowArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'FollowIncludeFromFollow'


class FindManyFollowArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['FollowOrderByInput', List['FollowOrderByInput']]
    where: 'FollowWhereInput'
    cursor: 'FollowWhereUniqueInput'
    distinct: List['FollowScalarFieldKeys']
    include: 'FollowIncludeFromFollow'


class PostIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    restaurant: Union[bool, 'RestaurantArgsFromMember']
    group: Union[bool, 'GroupArgsFromMember']
    profile: Union[bool, 'ProfileArgsFromMember']
    comments: Union[bool, 'FindManyCommentArgsFromMember']
    likes: Union[bool, 'FindManyPostLikeArgsFromMember']
    postTags: Union[bool, 'FindManyPostTagArgsFromMember']
    postImages: Union[bool, 'FindManyPostImageArgsFromMember']


class PostArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'PostIncludeFromPost'


class FindManyPostArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPost'


class PostTagIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    post: Union[bool, 'PostArgsFromMember']
    profile: Union[bool, 'ProfileArgsFromMember']


class PostTagArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'PostTagIncludeFromPostTag'


class FindManyPostTagArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['PostTagOrderByInput', List['PostTagOrderByInput']]
    where: 'PostTagWhereInput'
    cursor: 'PostTagWhereUniqueInput'
    distinct: List['PostTagScalarFieldKeys']
    include: 'PostTagIncludeFromPostTag'


class PostImageIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    post: Union[bool, 'PostArgsFromMember']


class PostImageArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'PostImageIncludeFromPostImage'


class FindManyPostImageArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['PostImageOrderByInput', List['PostImageOrderByInput']]
    where: 'PostImageWhereInput'
    cursor: 'PostImageWhereUniqueInput'
    distinct: List['PostImageScalarFieldKeys']
    include: 'PostImageIncludeFromPostImage'


class GroupIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    members: Union[bool, 'FindManyMemberArgsFromMember']
    posts: Union[bool, 'FindManyPostArgsFromMember']


class GroupArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'GroupIncludeFromGroup'


class FindManyGroupArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['GroupOrderByInput', List['GroupOrderByInput']]
    where: 'GroupWhereInput'
    cursor: 'GroupWhereUniqueInput'
    distinct: List['GroupScalarFieldKeys']
    include: 'GroupIncludeFromGroup'


class MemberIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    profile: Union[bool, 'ProfileArgsFromMember']
    group: Union[bool, 'GroupArgsFromMember']


class MemberArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'MemberIncludeFromMember'


class FindManyMemberArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMember'


class CommentIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    replies: Union[bool, 'FindManyCommentArgsFromMember']
    likes: Union[bool, 'FindManyCommentLikeArgsFromMember']
    parent: Union[bool, 'CommentArgsFromMember']
    post: Union[bool, 'PostArgsFromMember']
    profile: Union[bool, 'ProfileArgsFromMember']


class CommentArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'CommentIncludeFromComment'


class FindManyCommentArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromComment'


class PostLikeIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    post: Union[bool, 'PostArgsFromMember']
    profile: Union[bool, 'ProfileArgsFromMember']


class PostLikeArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'PostLikeIncludeFromPostLike'


class FindManyPostLikeArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['PostLikeOrderByInput', List['PostLikeOrderByInput']]
    where: 'PostLikeWhereInput'
    cursor: 'PostLikeWhereUniqueInput'
    distinct: List['PostLikeScalarFieldKeys']
    include: 'PostLikeIncludeFromPostLike'


class CommentLikeIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    comment: Union[bool, 'CommentArgsFromMember']
    profile: Union[bool, 'ProfileArgsFromMember']


class CommentLikeArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'CommentLikeIncludeFromCommentLike'


class FindManyCommentLikeArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['CommentLikeOrderByInput', List['CommentLikeOrderByInput']]
    where: 'CommentLikeWhereInput'
    cursor: 'CommentLikeWhereUniqueInput'
    distinct: List['CommentLikeScalarFieldKeys']
    include: 'CommentLikeIncludeFromCommentLike'


class RestaurantIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    posts: Union[bool, 'FindManyPostArgsFromMember']


class RestaurantArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'RestaurantIncludeFromRestaurant'


class FindManyRestaurantArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['RestaurantOrderByInput', List['RestaurantOrderByInput']]
    where: 'RestaurantWhereInput'
    cursor: 'RestaurantWhereUniqueInput'
    distinct: List['RestaurantScalarFieldKeys']
    include: 'RestaurantIncludeFromRestaurant'




FindManyMemberArgs = FindManyMemberArgsFromMember
FindFirstMemberArgs = FindManyMemberArgsFromMember


class MemberWhereInput(TypedDict, total=False):
    """Member arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    profile: 'ProfileRelationFilter'
    profileId: Union[_str, 'types.StringFilter']
    group: 'GroupRelationFilter'
    groupId: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['MemberWhereInput', List['MemberWhereInput']]
    # but this causes mypy to hang :/
    AND: List['MemberWhereInput']
    OR: List['MemberWhereInput']
    NOT: List['MemberWhereInput']



# aggregate Member types


class MemberScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Member arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    profileId: Union[_str, 'types.StringWithAggregatesFilter']
    groupId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['MemberScalarWhereWithAggregatesInput']
    OR: List['MemberScalarWhereWithAggregatesInput']
    NOT: List['MemberScalarWhereWithAggregatesInput']



class MemberGroupByOutput(TypedDict, total=False):
    id: _str
    profileId: _str
    groupId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'MemberSumAggregateOutput'
    _avg: 'MemberAvgAggregateOutput'
    _min: 'MemberMinAggregateOutput'
    _max: 'MemberMaxAggregateOutput'
    _count: 'MemberCountAggregateOutput'


class MemberAvgAggregateOutput(TypedDict, total=False):
    """Member output for aggregating averages"""


class MemberSumAggregateOutput(TypedDict, total=False):
    """Member output for aggregating sums"""


class MemberScalarAggregateOutput(TypedDict, total=False):
    """Member output including scalar fields"""
    id: _str
    profileId: _str
    groupId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


MemberMinAggregateOutput = MemberScalarAggregateOutput
MemberMaxAggregateOutput = MemberScalarAggregateOutput


class MemberMaxAggregateInput(TypedDict, total=False):
    """Member input for aggregating by max"""
    id: bool
    profileId: bool
    groupId: bool
    createdAt: bool
    updatedAt: bool


class MemberMinAggregateInput(TypedDict, total=False):
    """Member input for aggregating by min"""
    id: bool
    profileId: bool
    groupId: bool
    createdAt: bool
    updatedAt: bool


class MemberNumberAggregateInput(TypedDict, total=False):
    """Member input for aggregating numbers"""


MemberAvgAggregateInput = MemberNumberAggregateInput
MemberSumAggregateInput = MemberNumberAggregateInput


MemberCountAggregateInput = TypedDict(
    'MemberCountAggregateInput',
    {
        'id': bool,
        'profileId': bool,
        'groupId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

MemberCountAggregateOutput = TypedDict(
    'MemberCountAggregateOutput',
    {
        'id': int,
        'profileId': int,
        'groupId': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


MemberKeys = Literal[
    'id',
    'profile',
    'profileId',
    'group',
    'groupId',
    'createdAt',
    'updatedAt',
]
MemberScalarFieldKeys = Literal[
    'id',
    'profileId',
    'groupId',
    'createdAt',
    'updatedAt',
]
MemberScalarFieldKeysT = TypeVar('MemberScalarFieldKeysT', bound=MemberScalarFieldKeys)

MemberRelationalFieldKeys = Literal[
        'profile',
        'group',
    ]

# Comment types

class CommentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Comment create method"""
    id: _str
    replies: 'CommentCreateManyNestedWithoutRelationsInput'
    likes: 'CommentLikeCreateManyNestedWithoutRelationsInput'
    parent: 'CommentCreateNestedWithoutRelationsInput'
    parentId: Optional[_str]
    post: 'PostCreateNestedWithoutRelationsInput'
    postId: _str
    profile: 'ProfileCreateNestedWithoutRelationsInput'
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CommentCreateInput(CommentOptionalCreateInput):
    """Required arguments to the Comment create method"""
    message: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CommentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Comment create method, without relations"""
    id: _str
    parentId: Optional[_str]
    postId: _str
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CommentCreateWithoutRelationsInput(CommentOptionalCreateWithoutRelationsInput):
    """Required arguments to the Comment create method, without relations"""
    message: _str


class CommentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CommentCreateWithoutRelationsInput'
    connect: 'CommentWhereUniqueInput'


class CommentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CommentCreateWithoutRelationsInput', List['CommentCreateWithoutRelationsInput']]
    connect: Union['CommentWhereUniqueInput', List['CommentWhereUniqueInput']]


_CommentWhereUnique_id_Input = TypedDict(
    '_CommentWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

CommentWhereUniqueInput = _CommentWhereUnique_id_Input


class CommentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    message: _str
    replies: 'CommentUpdateManyWithoutRelationsInput'
    likes: 'CommentLikeUpdateManyWithoutRelationsInput'
    parent: 'CommentUpdateOneWithoutRelationsInput'
    post: 'PostUpdateOneWithoutRelationsInput'
    profile: 'ProfileUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CommentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    message: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CommentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CommentCreateWithoutRelationsInput']
    connect: List['CommentWhereUniqueInput']
    set: List['CommentWhereUniqueInput']
    disconnect: List['CommentWhereUniqueInput']
    delete: List['CommentWhereUniqueInput']

    # TODO
    # update: List['CommentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CommentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CommentScalarWhereInput']
    # upsert: List['CommentUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['CommentCreateOrConnectWithoutRelationsInput']


class CommentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CommentCreateWithoutRelationsInput'
    connect: 'CommentWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CommentUpdateInput'
    # upsert: 'CommentUpsertWithoutRelationsInput'
    # connectOrCreate: 'CommentCreateOrConnectWithoutRelationsInput'


class CommentUpsertInput(TypedDict):
    create: 'CommentCreateInput'
    update: 'CommentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Comment_id_OrderByInput = TypedDict(
    '_Comment_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Comment_message_OrderByInput = TypedDict(
    '_Comment_message_OrderByInput',
    {
        'message': 'SortOrder',
    },
    total=True
)

_Comment_parentId_OrderByInput = TypedDict(
    '_Comment_parentId_OrderByInput',
    {
        'parentId': 'SortOrder',
    },
    total=True
)

_Comment_postId_OrderByInput = TypedDict(
    '_Comment_postId_OrderByInput',
    {
        'postId': 'SortOrder',
    },
    total=True
)

_Comment_profileId_OrderByInput = TypedDict(
    '_Comment_profileId_OrderByInput',
    {
        'profileId': 'SortOrder',
    },
    total=True
)

_Comment_createdAt_OrderByInput = TypedDict(
    '_Comment_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Comment_updatedAt_OrderByInput = TypedDict(
    '_Comment_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

CommentOrderByInput = Union[
    '_Comment_id_OrderByInput',
    '_Comment_message_OrderByInput',
    '_Comment_parentId_OrderByInput',
    '_Comment_postId_OrderByInput',
    '_Comment_profileId_OrderByInput',
    '_Comment_createdAt_OrderByInput',
    '_Comment_updatedAt_OrderByInput',
]



# recursive Comment types
# TODO: cleanup these types



CommentRelationFilter = TypedDict(
    'CommentRelationFilter',
    {
        'is': 'CommentWhereInput',
        'is_not': 'CommentWhereInput',
    },
    total=False,
)


class CommentListRelationFilter(TypedDict, total=False):
    some: 'CommentWhereInput'
    none: 'CommentWhereInput'
    every: 'CommentWhereInput'


class CommentInclude(TypedDict, total=False):
    """Comment relational arguments"""
    replies: Union[bool, 'FindManyCommentArgsFromComment']
    likes: Union[bool, 'FindManyCommentLikeArgsFromComment']
    parent: Union[bool, 'CommentArgsFromComment']
    post: Union[bool, 'PostArgsFromComment']
    profile: Union[bool, 'ProfileArgsFromComment']


class ProfileIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    followsFollowing: Union[bool, 'FindManyFollowArgsFromComment']
    followsFollowed: Union[bool, 'FindManyFollowArgsFromComment']
    posts: Union[bool, 'FindManyPostArgsFromComment']
    postTags: Union[bool, 'FindManyPostTagArgsFromComment']
    members: Union[bool, 'FindManyMemberArgsFromComment']
    comments: Union[bool, 'FindManyCommentArgsFromComment']
    postLikes: Union[bool, 'FindManyPostLikeArgsFromComment']
    commentLikes: Union[bool, 'FindManyCommentLikeArgsFromComment']


class ProfileArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'ProfileIncludeFromProfile'


class FindManyProfileArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfile'


class FollowIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    following: Union[bool, 'ProfileArgsFromComment']
    followed: Union[bool, 'ProfileArgsFromComment']


class FollowArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'FollowIncludeFromFollow'


class FindManyFollowArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['FollowOrderByInput', List['FollowOrderByInput']]
    where: 'FollowWhereInput'
    cursor: 'FollowWhereUniqueInput'
    distinct: List['FollowScalarFieldKeys']
    include: 'FollowIncludeFromFollow'


class PostIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    restaurant: Union[bool, 'RestaurantArgsFromComment']
    group: Union[bool, 'GroupArgsFromComment']
    profile: Union[bool, 'ProfileArgsFromComment']
    comments: Union[bool, 'FindManyCommentArgsFromComment']
    likes: Union[bool, 'FindManyPostLikeArgsFromComment']
    postTags: Union[bool, 'FindManyPostTagArgsFromComment']
    postImages: Union[bool, 'FindManyPostImageArgsFromComment']


class PostArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'PostIncludeFromPost'


class FindManyPostArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPost'


class PostTagIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    post: Union[bool, 'PostArgsFromComment']
    profile: Union[bool, 'ProfileArgsFromComment']


class PostTagArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'PostTagIncludeFromPostTag'


class FindManyPostTagArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['PostTagOrderByInput', List['PostTagOrderByInput']]
    where: 'PostTagWhereInput'
    cursor: 'PostTagWhereUniqueInput'
    distinct: List['PostTagScalarFieldKeys']
    include: 'PostTagIncludeFromPostTag'


class PostImageIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    post: Union[bool, 'PostArgsFromComment']


class PostImageArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'PostImageIncludeFromPostImage'


class FindManyPostImageArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['PostImageOrderByInput', List['PostImageOrderByInput']]
    where: 'PostImageWhereInput'
    cursor: 'PostImageWhereUniqueInput'
    distinct: List['PostImageScalarFieldKeys']
    include: 'PostImageIncludeFromPostImage'


class GroupIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    members: Union[bool, 'FindManyMemberArgsFromComment']
    posts: Union[bool, 'FindManyPostArgsFromComment']


class GroupArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'GroupIncludeFromGroup'


class FindManyGroupArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['GroupOrderByInput', List['GroupOrderByInput']]
    where: 'GroupWhereInput'
    cursor: 'GroupWhereUniqueInput'
    distinct: List['GroupScalarFieldKeys']
    include: 'GroupIncludeFromGroup'


class MemberIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    profile: Union[bool, 'ProfileArgsFromComment']
    group: Union[bool, 'GroupArgsFromComment']


class MemberArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'MemberIncludeFromMember'


class FindManyMemberArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMember'


class CommentIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    replies: Union[bool, 'FindManyCommentArgsFromComment']
    likes: Union[bool, 'FindManyCommentLikeArgsFromComment']
    parent: Union[bool, 'CommentArgsFromComment']
    post: Union[bool, 'PostArgsFromComment']
    profile: Union[bool, 'ProfileArgsFromComment']


class CommentArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'CommentIncludeFromComment'


class FindManyCommentArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromComment'


class PostLikeIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    post: Union[bool, 'PostArgsFromComment']
    profile: Union[bool, 'ProfileArgsFromComment']


class PostLikeArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'PostLikeIncludeFromPostLike'


class FindManyPostLikeArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['PostLikeOrderByInput', List['PostLikeOrderByInput']]
    where: 'PostLikeWhereInput'
    cursor: 'PostLikeWhereUniqueInput'
    distinct: List['PostLikeScalarFieldKeys']
    include: 'PostLikeIncludeFromPostLike'


class CommentLikeIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    comment: Union[bool, 'CommentArgsFromComment']
    profile: Union[bool, 'ProfileArgsFromComment']


class CommentLikeArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'CommentLikeIncludeFromCommentLike'


class FindManyCommentLikeArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentLikeOrderByInput', List['CommentLikeOrderByInput']]
    where: 'CommentLikeWhereInput'
    cursor: 'CommentLikeWhereUniqueInput'
    distinct: List['CommentLikeScalarFieldKeys']
    include: 'CommentLikeIncludeFromCommentLike'


class RestaurantIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    posts: Union[bool, 'FindManyPostArgsFromComment']


class RestaurantArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'RestaurantIncludeFromRestaurant'


class FindManyRestaurantArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['RestaurantOrderByInput', List['RestaurantOrderByInput']]
    where: 'RestaurantWhereInput'
    cursor: 'RestaurantWhereUniqueInput'
    distinct: List['RestaurantScalarFieldKeys']
    include: 'RestaurantIncludeFromRestaurant'




FindManyCommentArgs = FindManyCommentArgsFromComment
FindFirstCommentArgs = FindManyCommentArgsFromComment


class CommentWhereInput(TypedDict, total=False):
    """Comment arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    replies: 'CommentListRelationFilter'
    likes: 'CommentLikeListRelationFilter'
    parent: 'CommentRelationFilter'
    parentId: Union[None, _str, 'types.StringFilter']
    post: 'PostRelationFilter'
    postId: Union[_str, 'types.StringFilter']
    profile: 'ProfileRelationFilter'
    profileId: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CommentWhereInput', List['CommentWhereInput']]
    # but this causes mypy to hang :/
    AND: List['CommentWhereInput']
    OR: List['CommentWhereInput']
    NOT: List['CommentWhereInput']



# aggregate Comment types


class CommentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Comment arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    parentId: Union[_str, 'types.StringWithAggregatesFilter']
    postId: Union[_str, 'types.StringWithAggregatesFilter']
    profileId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CommentScalarWhereWithAggregatesInput']
    OR: List['CommentScalarWhereWithAggregatesInput']
    NOT: List['CommentScalarWhereWithAggregatesInput']



class CommentGroupByOutput(TypedDict, total=False):
    id: _str
    message: _str
    parentId: _str
    postId: _str
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'CommentSumAggregateOutput'
    _avg: 'CommentAvgAggregateOutput'
    _min: 'CommentMinAggregateOutput'
    _max: 'CommentMaxAggregateOutput'
    _count: 'CommentCountAggregateOutput'


class CommentAvgAggregateOutput(TypedDict, total=False):
    """Comment output for aggregating averages"""


class CommentSumAggregateOutput(TypedDict, total=False):
    """Comment output for aggregating sums"""


class CommentScalarAggregateOutput(TypedDict, total=False):
    """Comment output including scalar fields"""
    id: _str
    message: _str
    parentId: _str
    postId: _str
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


CommentMinAggregateOutput = CommentScalarAggregateOutput
CommentMaxAggregateOutput = CommentScalarAggregateOutput


class CommentMaxAggregateInput(TypedDict, total=False):
    """Comment input for aggregating by max"""
    id: bool
    message: bool
    parentId: bool
    postId: bool
    profileId: bool
    createdAt: bool
    updatedAt: bool


class CommentMinAggregateInput(TypedDict, total=False):
    """Comment input for aggregating by min"""
    id: bool
    message: bool
    parentId: bool
    postId: bool
    profileId: bool
    createdAt: bool
    updatedAt: bool


class CommentNumberAggregateInput(TypedDict, total=False):
    """Comment input for aggregating numbers"""


CommentAvgAggregateInput = CommentNumberAggregateInput
CommentSumAggregateInput = CommentNumberAggregateInput


CommentCountAggregateInput = TypedDict(
    'CommentCountAggregateInput',
    {
        'id': bool,
        'message': bool,
        'parentId': bool,
        'postId': bool,
        'profileId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

CommentCountAggregateOutput = TypedDict(
    'CommentCountAggregateOutput',
    {
        'id': int,
        'message': int,
        'parentId': int,
        'postId': int,
        'profileId': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


CommentKeys = Literal[
    'id',
    'message',
    'replies',
    'likes',
    'parent',
    'parentId',
    'post',
    'postId',
    'profile',
    'profileId',
    'createdAt',
    'updatedAt',
]
CommentScalarFieldKeys = Literal[
    'id',
    'message',
    'parentId',
    'postId',
    'profileId',
    'createdAt',
    'updatedAt',
]
CommentScalarFieldKeysT = TypeVar('CommentScalarFieldKeysT', bound=CommentScalarFieldKeys)

CommentRelationalFieldKeys = Literal[
        'replies',
        'likes',
        'parent',
        'post',
        'profile',
    ]

# PostLike types

class PostLikeOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the PostLike create method"""
    id: _str
    post: 'PostCreateNestedWithoutRelationsInput'
    postId: _str
    profile: 'ProfileCreateNestedWithoutRelationsInput'
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostLikeCreateInput(PostLikeOptionalCreateInput):
    """Required arguments to the PostLike create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PostLikeOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the PostLike create method, without relations"""
    id: _str
    postId: _str
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostLikeCreateWithoutRelationsInput(PostLikeOptionalCreateWithoutRelationsInput):
    """Required arguments to the PostLike create method, without relations"""


class PostLikeCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PostLikeCreateWithoutRelationsInput'
    connect: 'PostLikeWhereUniqueInput'


class PostLikeCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PostLikeCreateWithoutRelationsInput', List['PostLikeCreateWithoutRelationsInput']]
    connect: Union['PostLikeWhereUniqueInput', List['PostLikeWhereUniqueInput']]


_PostLikeWhereUnique_id_Input = TypedDict(
    '_PostLikeWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

PostLikeWhereUniqueInput = _PostLikeWhereUnique_id_Input


class PostLikeUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    post: 'PostUpdateOneWithoutRelationsInput'
    profile: 'ProfileUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostLikeUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PostLikeUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PostLikeCreateWithoutRelationsInput']
    connect: List['PostLikeWhereUniqueInput']
    set: List['PostLikeWhereUniqueInput']
    disconnect: List['PostLikeWhereUniqueInput']
    delete: List['PostLikeWhereUniqueInput']

    # TODO
    # update: List['PostLikeUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PostLikeUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PostLikeScalarWhereInput']
    # upsert: List['PostLikeUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['PostLikeCreateOrConnectWithoutRelationsInput']


class PostLikeUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PostLikeCreateWithoutRelationsInput'
    connect: 'PostLikeWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PostLikeUpdateInput'
    # upsert: 'PostLikeUpsertWithoutRelationsInput'
    # connectOrCreate: 'PostLikeCreateOrConnectWithoutRelationsInput'


class PostLikeUpsertInput(TypedDict):
    create: 'PostLikeCreateInput'
    update: 'PostLikeUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_PostLike_id_OrderByInput = TypedDict(
    '_PostLike_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_PostLike_postId_OrderByInput = TypedDict(
    '_PostLike_postId_OrderByInput',
    {
        'postId': 'SortOrder',
    },
    total=True
)

_PostLike_profileId_OrderByInput = TypedDict(
    '_PostLike_profileId_OrderByInput',
    {
        'profileId': 'SortOrder',
    },
    total=True
)

_PostLike_createdAt_OrderByInput = TypedDict(
    '_PostLike_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_PostLike_updatedAt_OrderByInput = TypedDict(
    '_PostLike_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

PostLikeOrderByInput = Union[
    '_PostLike_id_OrderByInput',
    '_PostLike_postId_OrderByInput',
    '_PostLike_profileId_OrderByInput',
    '_PostLike_createdAt_OrderByInput',
    '_PostLike_updatedAt_OrderByInput',
]



# recursive PostLike types
# TODO: cleanup these types



PostLikeRelationFilter = TypedDict(
    'PostLikeRelationFilter',
    {
        'is': 'PostLikeWhereInput',
        'is_not': 'PostLikeWhereInput',
    },
    total=False,
)


class PostLikeListRelationFilter(TypedDict, total=False):
    some: 'PostLikeWhereInput'
    none: 'PostLikeWhereInput'
    every: 'PostLikeWhereInput'


class PostLikeInclude(TypedDict, total=False):
    """PostLike relational arguments"""
    post: Union[bool, 'PostArgsFromPostLike']
    profile: Union[bool, 'ProfileArgsFromPostLike']


class ProfileIncludeFromPostLike(TypedDict, total=False):
    """Relational arguments for PostLike"""
    followsFollowing: Union[bool, 'FindManyFollowArgsFromPostLike']
    followsFollowed: Union[bool, 'FindManyFollowArgsFromPostLike']
    posts: Union[bool, 'FindManyPostArgsFromPostLike']
    postTags: Union[bool, 'FindManyPostTagArgsFromPostLike']
    members: Union[bool, 'FindManyMemberArgsFromPostLike']
    comments: Union[bool, 'FindManyCommentArgsFromPostLike']
    postLikes: Union[bool, 'FindManyPostLikeArgsFromPostLike']
    commentLikes: Union[bool, 'FindManyCommentLikeArgsFromPostLike']


class ProfileArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    include: 'ProfileIncludeFromProfile'


class FindManyProfileArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfile'


class FollowIncludeFromPostLike(TypedDict, total=False):
    """Relational arguments for PostLike"""
    following: Union[bool, 'ProfileArgsFromPostLike']
    followed: Union[bool, 'ProfileArgsFromPostLike']


class FollowArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    include: 'FollowIncludeFromFollow'


class FindManyFollowArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    take: int
    skip: int
    order_by: Union['FollowOrderByInput', List['FollowOrderByInput']]
    where: 'FollowWhereInput'
    cursor: 'FollowWhereUniqueInput'
    distinct: List['FollowScalarFieldKeys']
    include: 'FollowIncludeFromFollow'


class PostIncludeFromPostLike(TypedDict, total=False):
    """Relational arguments for PostLike"""
    restaurant: Union[bool, 'RestaurantArgsFromPostLike']
    group: Union[bool, 'GroupArgsFromPostLike']
    profile: Union[bool, 'ProfileArgsFromPostLike']
    comments: Union[bool, 'FindManyCommentArgsFromPostLike']
    likes: Union[bool, 'FindManyPostLikeArgsFromPostLike']
    postTags: Union[bool, 'FindManyPostTagArgsFromPostLike']
    postImages: Union[bool, 'FindManyPostImageArgsFromPostLike']


class PostArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    include: 'PostIncludeFromPost'


class FindManyPostArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPost'


class PostTagIncludeFromPostLike(TypedDict, total=False):
    """Relational arguments for PostLike"""
    post: Union[bool, 'PostArgsFromPostLike']
    profile: Union[bool, 'ProfileArgsFromPostLike']


class PostTagArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    include: 'PostTagIncludeFromPostTag'


class FindManyPostTagArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    take: int
    skip: int
    order_by: Union['PostTagOrderByInput', List['PostTagOrderByInput']]
    where: 'PostTagWhereInput'
    cursor: 'PostTagWhereUniqueInput'
    distinct: List['PostTagScalarFieldKeys']
    include: 'PostTagIncludeFromPostTag'


class PostImageIncludeFromPostLike(TypedDict, total=False):
    """Relational arguments for PostLike"""
    post: Union[bool, 'PostArgsFromPostLike']


class PostImageArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    include: 'PostImageIncludeFromPostImage'


class FindManyPostImageArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    take: int
    skip: int
    order_by: Union['PostImageOrderByInput', List['PostImageOrderByInput']]
    where: 'PostImageWhereInput'
    cursor: 'PostImageWhereUniqueInput'
    distinct: List['PostImageScalarFieldKeys']
    include: 'PostImageIncludeFromPostImage'


class GroupIncludeFromPostLike(TypedDict, total=False):
    """Relational arguments for PostLike"""
    members: Union[bool, 'FindManyMemberArgsFromPostLike']
    posts: Union[bool, 'FindManyPostArgsFromPostLike']


class GroupArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    include: 'GroupIncludeFromGroup'


class FindManyGroupArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    take: int
    skip: int
    order_by: Union['GroupOrderByInput', List['GroupOrderByInput']]
    where: 'GroupWhereInput'
    cursor: 'GroupWhereUniqueInput'
    distinct: List['GroupScalarFieldKeys']
    include: 'GroupIncludeFromGroup'


class MemberIncludeFromPostLike(TypedDict, total=False):
    """Relational arguments for PostLike"""
    profile: Union[bool, 'ProfileArgsFromPostLike']
    group: Union[bool, 'GroupArgsFromPostLike']


class MemberArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    include: 'MemberIncludeFromMember'


class FindManyMemberArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMember'


class CommentIncludeFromPostLike(TypedDict, total=False):
    """Relational arguments for PostLike"""
    replies: Union[bool, 'FindManyCommentArgsFromPostLike']
    likes: Union[bool, 'FindManyCommentLikeArgsFromPostLike']
    parent: Union[bool, 'CommentArgsFromPostLike']
    post: Union[bool, 'PostArgsFromPostLike']
    profile: Union[bool, 'ProfileArgsFromPostLike']


class CommentArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    include: 'CommentIncludeFromComment'


class FindManyCommentArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromComment'


class PostLikeIncludeFromPostLike(TypedDict, total=False):
    """Relational arguments for PostLike"""
    post: Union[bool, 'PostArgsFromPostLike']
    profile: Union[bool, 'ProfileArgsFromPostLike']


class PostLikeArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    include: 'PostLikeIncludeFromPostLike'


class FindManyPostLikeArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    take: int
    skip: int
    order_by: Union['PostLikeOrderByInput', List['PostLikeOrderByInput']]
    where: 'PostLikeWhereInput'
    cursor: 'PostLikeWhereUniqueInput'
    distinct: List['PostLikeScalarFieldKeys']
    include: 'PostLikeIncludeFromPostLike'


class CommentLikeIncludeFromPostLike(TypedDict, total=False):
    """Relational arguments for PostLike"""
    comment: Union[bool, 'CommentArgsFromPostLike']
    profile: Union[bool, 'ProfileArgsFromPostLike']


class CommentLikeArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    include: 'CommentLikeIncludeFromCommentLike'


class FindManyCommentLikeArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    take: int
    skip: int
    order_by: Union['CommentLikeOrderByInput', List['CommentLikeOrderByInput']]
    where: 'CommentLikeWhereInput'
    cursor: 'CommentLikeWhereUniqueInput'
    distinct: List['CommentLikeScalarFieldKeys']
    include: 'CommentLikeIncludeFromCommentLike'


class RestaurantIncludeFromPostLike(TypedDict, total=False):
    """Relational arguments for PostLike"""
    posts: Union[bool, 'FindManyPostArgsFromPostLike']


class RestaurantArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    include: 'RestaurantIncludeFromRestaurant'


class FindManyRestaurantArgsFromPostLike(TypedDict, total=False):
    """Arguments for PostLike"""
    take: int
    skip: int
    order_by: Union['RestaurantOrderByInput', List['RestaurantOrderByInput']]
    where: 'RestaurantWhereInput'
    cursor: 'RestaurantWhereUniqueInput'
    distinct: List['RestaurantScalarFieldKeys']
    include: 'RestaurantIncludeFromRestaurant'




FindManyPostLikeArgs = FindManyPostLikeArgsFromPostLike
FindFirstPostLikeArgs = FindManyPostLikeArgsFromPostLike


class PostLikeWhereInput(TypedDict, total=False):
    """PostLike arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    post: 'PostRelationFilter'
    postId: Union[_str, 'types.StringFilter']
    profile: 'ProfileRelationFilter'
    profileId: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['PostLikeWhereInput', List['PostLikeWhereInput']]
    # but this causes mypy to hang :/
    AND: List['PostLikeWhereInput']
    OR: List['PostLikeWhereInput']
    NOT: List['PostLikeWhereInput']



# aggregate PostLike types


class PostLikeScalarWhereWithAggregatesInput(TypedDict, total=False):
    """PostLike arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    postId: Union[_str, 'types.StringWithAggregatesFilter']
    profileId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PostLikeScalarWhereWithAggregatesInput']
    OR: List['PostLikeScalarWhereWithAggregatesInput']
    NOT: List['PostLikeScalarWhereWithAggregatesInput']



class PostLikeGroupByOutput(TypedDict, total=False):
    id: _str
    postId: _str
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'PostLikeSumAggregateOutput'
    _avg: 'PostLikeAvgAggregateOutput'
    _min: 'PostLikeMinAggregateOutput'
    _max: 'PostLikeMaxAggregateOutput'
    _count: 'PostLikeCountAggregateOutput'


class PostLikeAvgAggregateOutput(TypedDict, total=False):
    """PostLike output for aggregating averages"""


class PostLikeSumAggregateOutput(TypedDict, total=False):
    """PostLike output for aggregating sums"""


class PostLikeScalarAggregateOutput(TypedDict, total=False):
    """PostLike output including scalar fields"""
    id: _str
    postId: _str
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


PostLikeMinAggregateOutput = PostLikeScalarAggregateOutput
PostLikeMaxAggregateOutput = PostLikeScalarAggregateOutput


class PostLikeMaxAggregateInput(TypedDict, total=False):
    """PostLike input for aggregating by max"""
    id: bool
    postId: bool
    profileId: bool
    createdAt: bool
    updatedAt: bool


class PostLikeMinAggregateInput(TypedDict, total=False):
    """PostLike input for aggregating by min"""
    id: bool
    postId: bool
    profileId: bool
    createdAt: bool
    updatedAt: bool


class PostLikeNumberAggregateInput(TypedDict, total=False):
    """PostLike input for aggregating numbers"""


PostLikeAvgAggregateInput = PostLikeNumberAggregateInput
PostLikeSumAggregateInput = PostLikeNumberAggregateInput


PostLikeCountAggregateInput = TypedDict(
    'PostLikeCountAggregateInput',
    {
        'id': bool,
        'postId': bool,
        'profileId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

PostLikeCountAggregateOutput = TypedDict(
    'PostLikeCountAggregateOutput',
    {
        'id': int,
        'postId': int,
        'profileId': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


PostLikeKeys = Literal[
    'id',
    'post',
    'postId',
    'profile',
    'profileId',
    'createdAt',
    'updatedAt',
]
PostLikeScalarFieldKeys = Literal[
    'id',
    'postId',
    'profileId',
    'createdAt',
    'updatedAt',
]
PostLikeScalarFieldKeysT = TypeVar('PostLikeScalarFieldKeysT', bound=PostLikeScalarFieldKeys)

PostLikeRelationalFieldKeys = Literal[
        'post',
        'profile',
    ]

# CommentLike types

class CommentLikeOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the CommentLike create method"""
    id: _str
    comment: 'CommentCreateNestedWithoutRelationsInput'
    commentId: _str
    profile: 'ProfileCreateNestedWithoutRelationsInput'
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CommentLikeCreateInput(CommentLikeOptionalCreateInput):
    """Required arguments to the CommentLike create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CommentLikeOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the CommentLike create method, without relations"""
    id: _str
    commentId: _str
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CommentLikeCreateWithoutRelationsInput(CommentLikeOptionalCreateWithoutRelationsInput):
    """Required arguments to the CommentLike create method, without relations"""


class CommentLikeCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CommentLikeCreateWithoutRelationsInput'
    connect: 'CommentLikeWhereUniqueInput'


class CommentLikeCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CommentLikeCreateWithoutRelationsInput', List['CommentLikeCreateWithoutRelationsInput']]
    connect: Union['CommentLikeWhereUniqueInput', List['CommentLikeWhereUniqueInput']]


_CommentLikeWhereUnique_id_Input = TypedDict(
    '_CommentLikeWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

CommentLikeWhereUniqueInput = _CommentLikeWhereUnique_id_Input


class CommentLikeUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    comment: 'CommentUpdateOneWithoutRelationsInput'
    profile: 'ProfileUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CommentLikeUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CommentLikeUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CommentLikeCreateWithoutRelationsInput']
    connect: List['CommentLikeWhereUniqueInput']
    set: List['CommentLikeWhereUniqueInput']
    disconnect: List['CommentLikeWhereUniqueInput']
    delete: List['CommentLikeWhereUniqueInput']

    # TODO
    # update: List['CommentLikeUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CommentLikeUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CommentLikeScalarWhereInput']
    # upsert: List['CommentLikeUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['CommentLikeCreateOrConnectWithoutRelationsInput']


class CommentLikeUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CommentLikeCreateWithoutRelationsInput'
    connect: 'CommentLikeWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CommentLikeUpdateInput'
    # upsert: 'CommentLikeUpsertWithoutRelationsInput'
    # connectOrCreate: 'CommentLikeCreateOrConnectWithoutRelationsInput'


class CommentLikeUpsertInput(TypedDict):
    create: 'CommentLikeCreateInput'
    update: 'CommentLikeUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_CommentLike_id_OrderByInput = TypedDict(
    '_CommentLike_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_CommentLike_commentId_OrderByInput = TypedDict(
    '_CommentLike_commentId_OrderByInput',
    {
        'commentId': 'SortOrder',
    },
    total=True
)

_CommentLike_profileId_OrderByInput = TypedDict(
    '_CommentLike_profileId_OrderByInput',
    {
        'profileId': 'SortOrder',
    },
    total=True
)

_CommentLike_createdAt_OrderByInput = TypedDict(
    '_CommentLike_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_CommentLike_updatedAt_OrderByInput = TypedDict(
    '_CommentLike_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

CommentLikeOrderByInput = Union[
    '_CommentLike_id_OrderByInput',
    '_CommentLike_commentId_OrderByInput',
    '_CommentLike_profileId_OrderByInput',
    '_CommentLike_createdAt_OrderByInput',
    '_CommentLike_updatedAt_OrderByInput',
]



# recursive CommentLike types
# TODO: cleanup these types



CommentLikeRelationFilter = TypedDict(
    'CommentLikeRelationFilter',
    {
        'is': 'CommentLikeWhereInput',
        'is_not': 'CommentLikeWhereInput',
    },
    total=False,
)


class CommentLikeListRelationFilter(TypedDict, total=False):
    some: 'CommentLikeWhereInput'
    none: 'CommentLikeWhereInput'
    every: 'CommentLikeWhereInput'


class CommentLikeInclude(TypedDict, total=False):
    """CommentLike relational arguments"""
    comment: Union[bool, 'CommentArgsFromCommentLike']
    profile: Union[bool, 'ProfileArgsFromCommentLike']


class ProfileIncludeFromCommentLike(TypedDict, total=False):
    """Relational arguments for CommentLike"""
    followsFollowing: Union[bool, 'FindManyFollowArgsFromCommentLike']
    followsFollowed: Union[bool, 'FindManyFollowArgsFromCommentLike']
    posts: Union[bool, 'FindManyPostArgsFromCommentLike']
    postTags: Union[bool, 'FindManyPostTagArgsFromCommentLike']
    members: Union[bool, 'FindManyMemberArgsFromCommentLike']
    comments: Union[bool, 'FindManyCommentArgsFromCommentLike']
    postLikes: Union[bool, 'FindManyPostLikeArgsFromCommentLike']
    commentLikes: Union[bool, 'FindManyCommentLikeArgsFromCommentLike']


class ProfileArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    include: 'ProfileIncludeFromProfile'


class FindManyProfileArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfile'


class FollowIncludeFromCommentLike(TypedDict, total=False):
    """Relational arguments for CommentLike"""
    following: Union[bool, 'ProfileArgsFromCommentLike']
    followed: Union[bool, 'ProfileArgsFromCommentLike']


class FollowArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    include: 'FollowIncludeFromFollow'


class FindManyFollowArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    take: int
    skip: int
    order_by: Union['FollowOrderByInput', List['FollowOrderByInput']]
    where: 'FollowWhereInput'
    cursor: 'FollowWhereUniqueInput'
    distinct: List['FollowScalarFieldKeys']
    include: 'FollowIncludeFromFollow'


class PostIncludeFromCommentLike(TypedDict, total=False):
    """Relational arguments for CommentLike"""
    restaurant: Union[bool, 'RestaurantArgsFromCommentLike']
    group: Union[bool, 'GroupArgsFromCommentLike']
    profile: Union[bool, 'ProfileArgsFromCommentLike']
    comments: Union[bool, 'FindManyCommentArgsFromCommentLike']
    likes: Union[bool, 'FindManyPostLikeArgsFromCommentLike']
    postTags: Union[bool, 'FindManyPostTagArgsFromCommentLike']
    postImages: Union[bool, 'FindManyPostImageArgsFromCommentLike']


class PostArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    include: 'PostIncludeFromPost'


class FindManyPostArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPost'


class PostTagIncludeFromCommentLike(TypedDict, total=False):
    """Relational arguments for CommentLike"""
    post: Union[bool, 'PostArgsFromCommentLike']
    profile: Union[bool, 'ProfileArgsFromCommentLike']


class PostTagArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    include: 'PostTagIncludeFromPostTag'


class FindManyPostTagArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    take: int
    skip: int
    order_by: Union['PostTagOrderByInput', List['PostTagOrderByInput']]
    where: 'PostTagWhereInput'
    cursor: 'PostTagWhereUniqueInput'
    distinct: List['PostTagScalarFieldKeys']
    include: 'PostTagIncludeFromPostTag'


class PostImageIncludeFromCommentLike(TypedDict, total=False):
    """Relational arguments for CommentLike"""
    post: Union[bool, 'PostArgsFromCommentLike']


class PostImageArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    include: 'PostImageIncludeFromPostImage'


class FindManyPostImageArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    take: int
    skip: int
    order_by: Union['PostImageOrderByInput', List['PostImageOrderByInput']]
    where: 'PostImageWhereInput'
    cursor: 'PostImageWhereUniqueInput'
    distinct: List['PostImageScalarFieldKeys']
    include: 'PostImageIncludeFromPostImage'


class GroupIncludeFromCommentLike(TypedDict, total=False):
    """Relational arguments for CommentLike"""
    members: Union[bool, 'FindManyMemberArgsFromCommentLike']
    posts: Union[bool, 'FindManyPostArgsFromCommentLike']


class GroupArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    include: 'GroupIncludeFromGroup'


class FindManyGroupArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    take: int
    skip: int
    order_by: Union['GroupOrderByInput', List['GroupOrderByInput']]
    where: 'GroupWhereInput'
    cursor: 'GroupWhereUniqueInput'
    distinct: List['GroupScalarFieldKeys']
    include: 'GroupIncludeFromGroup'


class MemberIncludeFromCommentLike(TypedDict, total=False):
    """Relational arguments for CommentLike"""
    profile: Union[bool, 'ProfileArgsFromCommentLike']
    group: Union[bool, 'GroupArgsFromCommentLike']


class MemberArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    include: 'MemberIncludeFromMember'


class FindManyMemberArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMember'


class CommentIncludeFromCommentLike(TypedDict, total=False):
    """Relational arguments for CommentLike"""
    replies: Union[bool, 'FindManyCommentArgsFromCommentLike']
    likes: Union[bool, 'FindManyCommentLikeArgsFromCommentLike']
    parent: Union[bool, 'CommentArgsFromCommentLike']
    post: Union[bool, 'PostArgsFromCommentLike']
    profile: Union[bool, 'ProfileArgsFromCommentLike']


class CommentArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    include: 'CommentIncludeFromComment'


class FindManyCommentArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromComment'


class PostLikeIncludeFromCommentLike(TypedDict, total=False):
    """Relational arguments for CommentLike"""
    post: Union[bool, 'PostArgsFromCommentLike']
    profile: Union[bool, 'ProfileArgsFromCommentLike']


class PostLikeArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    include: 'PostLikeIncludeFromPostLike'


class FindManyPostLikeArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    take: int
    skip: int
    order_by: Union['PostLikeOrderByInput', List['PostLikeOrderByInput']]
    where: 'PostLikeWhereInput'
    cursor: 'PostLikeWhereUniqueInput'
    distinct: List['PostLikeScalarFieldKeys']
    include: 'PostLikeIncludeFromPostLike'


class CommentLikeIncludeFromCommentLike(TypedDict, total=False):
    """Relational arguments for CommentLike"""
    comment: Union[bool, 'CommentArgsFromCommentLike']
    profile: Union[bool, 'ProfileArgsFromCommentLike']


class CommentLikeArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    include: 'CommentLikeIncludeFromCommentLike'


class FindManyCommentLikeArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    take: int
    skip: int
    order_by: Union['CommentLikeOrderByInput', List['CommentLikeOrderByInput']]
    where: 'CommentLikeWhereInput'
    cursor: 'CommentLikeWhereUniqueInput'
    distinct: List['CommentLikeScalarFieldKeys']
    include: 'CommentLikeIncludeFromCommentLike'


class RestaurantIncludeFromCommentLike(TypedDict, total=False):
    """Relational arguments for CommentLike"""
    posts: Union[bool, 'FindManyPostArgsFromCommentLike']


class RestaurantArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    include: 'RestaurantIncludeFromRestaurant'


class FindManyRestaurantArgsFromCommentLike(TypedDict, total=False):
    """Arguments for CommentLike"""
    take: int
    skip: int
    order_by: Union['RestaurantOrderByInput', List['RestaurantOrderByInput']]
    where: 'RestaurantWhereInput'
    cursor: 'RestaurantWhereUniqueInput'
    distinct: List['RestaurantScalarFieldKeys']
    include: 'RestaurantIncludeFromRestaurant'




FindManyCommentLikeArgs = FindManyCommentLikeArgsFromCommentLike
FindFirstCommentLikeArgs = FindManyCommentLikeArgsFromCommentLike


class CommentLikeWhereInput(TypedDict, total=False):
    """CommentLike arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    comment: 'CommentRelationFilter'
    commentId: Union[_str, 'types.StringFilter']
    profile: 'ProfileRelationFilter'
    profileId: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CommentLikeWhereInput', List['CommentLikeWhereInput']]
    # but this causes mypy to hang :/
    AND: List['CommentLikeWhereInput']
    OR: List['CommentLikeWhereInput']
    NOT: List['CommentLikeWhereInput']



# aggregate CommentLike types


class CommentLikeScalarWhereWithAggregatesInput(TypedDict, total=False):
    """CommentLike arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    commentId: Union[_str, 'types.StringWithAggregatesFilter']
    profileId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CommentLikeScalarWhereWithAggregatesInput']
    OR: List['CommentLikeScalarWhereWithAggregatesInput']
    NOT: List['CommentLikeScalarWhereWithAggregatesInput']



class CommentLikeGroupByOutput(TypedDict, total=False):
    id: _str
    commentId: _str
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'CommentLikeSumAggregateOutput'
    _avg: 'CommentLikeAvgAggregateOutput'
    _min: 'CommentLikeMinAggregateOutput'
    _max: 'CommentLikeMaxAggregateOutput'
    _count: 'CommentLikeCountAggregateOutput'


class CommentLikeAvgAggregateOutput(TypedDict, total=False):
    """CommentLike output for aggregating averages"""


class CommentLikeSumAggregateOutput(TypedDict, total=False):
    """CommentLike output for aggregating sums"""


class CommentLikeScalarAggregateOutput(TypedDict, total=False):
    """CommentLike output including scalar fields"""
    id: _str
    commentId: _str
    profileId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


CommentLikeMinAggregateOutput = CommentLikeScalarAggregateOutput
CommentLikeMaxAggregateOutput = CommentLikeScalarAggregateOutput


class CommentLikeMaxAggregateInput(TypedDict, total=False):
    """CommentLike input for aggregating by max"""
    id: bool
    commentId: bool
    profileId: bool
    createdAt: bool
    updatedAt: bool


class CommentLikeMinAggregateInput(TypedDict, total=False):
    """CommentLike input for aggregating by min"""
    id: bool
    commentId: bool
    profileId: bool
    createdAt: bool
    updatedAt: bool


class CommentLikeNumberAggregateInput(TypedDict, total=False):
    """CommentLike input for aggregating numbers"""


CommentLikeAvgAggregateInput = CommentLikeNumberAggregateInput
CommentLikeSumAggregateInput = CommentLikeNumberAggregateInput


CommentLikeCountAggregateInput = TypedDict(
    'CommentLikeCountAggregateInput',
    {
        'id': bool,
        'commentId': bool,
        'profileId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

CommentLikeCountAggregateOutput = TypedDict(
    'CommentLikeCountAggregateOutput',
    {
        'id': int,
        'commentId': int,
        'profileId': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


CommentLikeKeys = Literal[
    'id',
    'comment',
    'commentId',
    'profile',
    'profileId',
    'createdAt',
    'updatedAt',
]
CommentLikeScalarFieldKeys = Literal[
    'id',
    'commentId',
    'profileId',
    'createdAt',
    'updatedAt',
]
CommentLikeScalarFieldKeysT = TypeVar('CommentLikeScalarFieldKeysT', bound=CommentLikeScalarFieldKeys)

CommentLikeRelationalFieldKeys = Literal[
        'comment',
        'profile',
    ]

# Restaurant types

class RestaurantOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Restaurant create method"""
    id: _str
    posts: 'PostCreateManyNestedWithoutRelationsInput'


class RestaurantCreateInput(RestaurantOptionalCreateInput):
    """Required arguments to the Restaurant create method"""
    name: _str
    yelpId: _str
    latitude: _str
    longitude: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class RestaurantOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Restaurant create method, without relations"""
    id: _str


class RestaurantCreateWithoutRelationsInput(RestaurantOptionalCreateWithoutRelationsInput):
    """Required arguments to the Restaurant create method, without relations"""
    name: _str
    yelpId: _str
    latitude: _str
    longitude: _str


class RestaurantCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'RestaurantCreateWithoutRelationsInput'
    connect: 'RestaurantWhereUniqueInput'


class RestaurantCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['RestaurantCreateWithoutRelationsInput', List['RestaurantCreateWithoutRelationsInput']]
    connect: Union['RestaurantWhereUniqueInput', List['RestaurantWhereUniqueInput']]


_RestaurantWhereUnique_id_Input = TypedDict(
    '_RestaurantWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_RestaurantWhereUnique_yelpId_Input = TypedDict(
    '_RestaurantWhereUnique_yelpId_Input',
    {
        'yelpId': '_str',
    },
    total=True
)

RestaurantWhereUniqueInput = Union[
    '_RestaurantWhereUnique_id_Input',
    '_RestaurantWhereUnique_yelpId_Input',
]


class RestaurantUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    yelpId: _str
    latitude: _str
    longitude: _str
    posts: 'PostUpdateManyWithoutRelationsInput'


class RestaurantUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    yelpId: _str
    latitude: _str
    longitude: _str


class RestaurantUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['RestaurantCreateWithoutRelationsInput']
    connect: List['RestaurantWhereUniqueInput']
    set: List['RestaurantWhereUniqueInput']
    disconnect: List['RestaurantWhereUniqueInput']
    delete: List['RestaurantWhereUniqueInput']

    # TODO
    # update: List['RestaurantUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['RestaurantUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['RestaurantScalarWhereInput']
    # upsert: List['RestaurantUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['RestaurantCreateOrConnectWithoutRelationsInput']


class RestaurantUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'RestaurantCreateWithoutRelationsInput'
    connect: 'RestaurantWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'RestaurantUpdateInput'
    # upsert: 'RestaurantUpsertWithoutRelationsInput'
    # connectOrCreate: 'RestaurantCreateOrConnectWithoutRelationsInput'


class RestaurantUpsertInput(TypedDict):
    create: 'RestaurantCreateInput'
    update: 'RestaurantUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Restaurant_id_OrderByInput = TypedDict(
    '_Restaurant_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Restaurant_name_OrderByInput = TypedDict(
    '_Restaurant_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Restaurant_yelpId_OrderByInput = TypedDict(
    '_Restaurant_yelpId_OrderByInput',
    {
        'yelpId': 'SortOrder',
    },
    total=True
)

_Restaurant_latitude_OrderByInput = TypedDict(
    '_Restaurant_latitude_OrderByInput',
    {
        'latitude': 'SortOrder',
    },
    total=True
)

_Restaurant_longitude_OrderByInput = TypedDict(
    '_Restaurant_longitude_OrderByInput',
    {
        'longitude': 'SortOrder',
    },
    total=True
)

RestaurantOrderByInput = Union[
    '_Restaurant_id_OrderByInput',
    '_Restaurant_name_OrderByInput',
    '_Restaurant_yelpId_OrderByInput',
    '_Restaurant_latitude_OrderByInput',
    '_Restaurant_longitude_OrderByInput',
]



# recursive Restaurant types
# TODO: cleanup these types



RestaurantRelationFilter = TypedDict(
    'RestaurantRelationFilter',
    {
        'is': 'RestaurantWhereInput',
        'is_not': 'RestaurantWhereInput',
    },
    total=False,
)


class RestaurantListRelationFilter(TypedDict, total=False):
    some: 'RestaurantWhereInput'
    none: 'RestaurantWhereInput'
    every: 'RestaurantWhereInput'


class RestaurantInclude(TypedDict, total=False):
    """Restaurant relational arguments"""
    posts: Union[bool, 'FindManyPostArgsFromRestaurant']


class ProfileIncludeFromRestaurant(TypedDict, total=False):
    """Relational arguments for Restaurant"""
    followsFollowing: Union[bool, 'FindManyFollowArgsFromRestaurant']
    followsFollowed: Union[bool, 'FindManyFollowArgsFromRestaurant']
    posts: Union[bool, 'FindManyPostArgsFromRestaurant']
    postTags: Union[bool, 'FindManyPostTagArgsFromRestaurant']
    members: Union[bool, 'FindManyMemberArgsFromRestaurant']
    comments: Union[bool, 'FindManyCommentArgsFromRestaurant']
    postLikes: Union[bool, 'FindManyPostLikeArgsFromRestaurant']
    commentLikes: Union[bool, 'FindManyCommentLikeArgsFromRestaurant']


class ProfileArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    include: 'ProfileIncludeFromProfile'


class FindManyProfileArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    take: int
    skip: int
    order_by: Union['ProfileOrderByInput', List['ProfileOrderByInput']]
    where: 'ProfileWhereInput'
    cursor: 'ProfileWhereUniqueInput'
    distinct: List['ProfileScalarFieldKeys']
    include: 'ProfileIncludeFromProfile'


class FollowIncludeFromRestaurant(TypedDict, total=False):
    """Relational arguments for Restaurant"""
    following: Union[bool, 'ProfileArgsFromRestaurant']
    followed: Union[bool, 'ProfileArgsFromRestaurant']


class FollowArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    include: 'FollowIncludeFromFollow'


class FindManyFollowArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    take: int
    skip: int
    order_by: Union['FollowOrderByInput', List['FollowOrderByInput']]
    where: 'FollowWhereInput'
    cursor: 'FollowWhereUniqueInput'
    distinct: List['FollowScalarFieldKeys']
    include: 'FollowIncludeFromFollow'


class PostIncludeFromRestaurant(TypedDict, total=False):
    """Relational arguments for Restaurant"""
    restaurant: Union[bool, 'RestaurantArgsFromRestaurant']
    group: Union[bool, 'GroupArgsFromRestaurant']
    profile: Union[bool, 'ProfileArgsFromRestaurant']
    comments: Union[bool, 'FindManyCommentArgsFromRestaurant']
    likes: Union[bool, 'FindManyPostLikeArgsFromRestaurant']
    postTags: Union[bool, 'FindManyPostTagArgsFromRestaurant']
    postImages: Union[bool, 'FindManyPostImageArgsFromRestaurant']


class PostArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    include: 'PostIncludeFromPost'


class FindManyPostArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromPost'


class PostTagIncludeFromRestaurant(TypedDict, total=False):
    """Relational arguments for Restaurant"""
    post: Union[bool, 'PostArgsFromRestaurant']
    profile: Union[bool, 'ProfileArgsFromRestaurant']


class PostTagArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    include: 'PostTagIncludeFromPostTag'


class FindManyPostTagArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    take: int
    skip: int
    order_by: Union['PostTagOrderByInput', List['PostTagOrderByInput']]
    where: 'PostTagWhereInput'
    cursor: 'PostTagWhereUniqueInput'
    distinct: List['PostTagScalarFieldKeys']
    include: 'PostTagIncludeFromPostTag'


class PostImageIncludeFromRestaurant(TypedDict, total=False):
    """Relational arguments for Restaurant"""
    post: Union[bool, 'PostArgsFromRestaurant']


class PostImageArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    include: 'PostImageIncludeFromPostImage'


class FindManyPostImageArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    take: int
    skip: int
    order_by: Union['PostImageOrderByInput', List['PostImageOrderByInput']]
    where: 'PostImageWhereInput'
    cursor: 'PostImageWhereUniqueInput'
    distinct: List['PostImageScalarFieldKeys']
    include: 'PostImageIncludeFromPostImage'


class GroupIncludeFromRestaurant(TypedDict, total=False):
    """Relational arguments for Restaurant"""
    members: Union[bool, 'FindManyMemberArgsFromRestaurant']
    posts: Union[bool, 'FindManyPostArgsFromRestaurant']


class GroupArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    include: 'GroupIncludeFromGroup'


class FindManyGroupArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    take: int
    skip: int
    order_by: Union['GroupOrderByInput', List['GroupOrderByInput']]
    where: 'GroupWhereInput'
    cursor: 'GroupWhereUniqueInput'
    distinct: List['GroupScalarFieldKeys']
    include: 'GroupIncludeFromGroup'


class MemberIncludeFromRestaurant(TypedDict, total=False):
    """Relational arguments for Restaurant"""
    profile: Union[bool, 'ProfileArgsFromRestaurant']
    group: Union[bool, 'GroupArgsFromRestaurant']


class MemberArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    include: 'MemberIncludeFromMember'


class FindManyMemberArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMember'


class CommentIncludeFromRestaurant(TypedDict, total=False):
    """Relational arguments for Restaurant"""
    replies: Union[bool, 'FindManyCommentArgsFromRestaurant']
    likes: Union[bool, 'FindManyCommentLikeArgsFromRestaurant']
    parent: Union[bool, 'CommentArgsFromRestaurant']
    post: Union[bool, 'PostArgsFromRestaurant']
    profile: Union[bool, 'ProfileArgsFromRestaurant']


class CommentArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    include: 'CommentIncludeFromComment'


class FindManyCommentArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromComment'


class PostLikeIncludeFromRestaurant(TypedDict, total=False):
    """Relational arguments for Restaurant"""
    post: Union[bool, 'PostArgsFromRestaurant']
    profile: Union[bool, 'ProfileArgsFromRestaurant']


class PostLikeArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    include: 'PostLikeIncludeFromPostLike'


class FindManyPostLikeArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    take: int
    skip: int
    order_by: Union['PostLikeOrderByInput', List['PostLikeOrderByInput']]
    where: 'PostLikeWhereInput'
    cursor: 'PostLikeWhereUniqueInput'
    distinct: List['PostLikeScalarFieldKeys']
    include: 'PostLikeIncludeFromPostLike'


class CommentLikeIncludeFromRestaurant(TypedDict, total=False):
    """Relational arguments for Restaurant"""
    comment: Union[bool, 'CommentArgsFromRestaurant']
    profile: Union[bool, 'ProfileArgsFromRestaurant']


class CommentLikeArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    include: 'CommentLikeIncludeFromCommentLike'


class FindManyCommentLikeArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    take: int
    skip: int
    order_by: Union['CommentLikeOrderByInput', List['CommentLikeOrderByInput']]
    where: 'CommentLikeWhereInput'
    cursor: 'CommentLikeWhereUniqueInput'
    distinct: List['CommentLikeScalarFieldKeys']
    include: 'CommentLikeIncludeFromCommentLike'


class RestaurantIncludeFromRestaurant(TypedDict, total=False):
    """Relational arguments for Restaurant"""
    posts: Union[bool, 'FindManyPostArgsFromRestaurant']


class RestaurantArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    include: 'RestaurantIncludeFromRestaurant'


class FindManyRestaurantArgsFromRestaurant(TypedDict, total=False):
    """Arguments for Restaurant"""
    take: int
    skip: int
    order_by: Union['RestaurantOrderByInput', List['RestaurantOrderByInput']]
    where: 'RestaurantWhereInput'
    cursor: 'RestaurantWhereUniqueInput'
    distinct: List['RestaurantScalarFieldKeys']
    include: 'RestaurantIncludeFromRestaurant'




FindManyRestaurantArgs = FindManyRestaurantArgsFromRestaurant
FindFirstRestaurantArgs = FindManyRestaurantArgsFromRestaurant


class RestaurantWhereInput(TypedDict, total=False):
    """Restaurant arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    yelpId: Union[_str, 'types.StringFilter']
    latitude: Union[_str, 'types.StringFilter']
    longitude: Union[_str, 'types.StringFilter']
    posts: 'PostListRelationFilter'

    # should be noted that AND and NOT should be Union['RestaurantWhereInput', List['RestaurantWhereInput']]
    # but this causes mypy to hang :/
    AND: List['RestaurantWhereInput']
    OR: List['RestaurantWhereInput']
    NOT: List['RestaurantWhereInput']



# aggregate Restaurant types


class RestaurantScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Restaurant arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    yelpId: Union[_str, 'types.StringWithAggregatesFilter']
    latitude: Union[_str, 'types.StringWithAggregatesFilter']
    longitude: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['RestaurantScalarWhereWithAggregatesInput']
    OR: List['RestaurantScalarWhereWithAggregatesInput']
    NOT: List['RestaurantScalarWhereWithAggregatesInput']



class RestaurantGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    yelpId: _str
    latitude: _str
    longitude: _str
    _sum: 'RestaurantSumAggregateOutput'
    _avg: 'RestaurantAvgAggregateOutput'
    _min: 'RestaurantMinAggregateOutput'
    _max: 'RestaurantMaxAggregateOutput'
    _count: 'RestaurantCountAggregateOutput'


class RestaurantAvgAggregateOutput(TypedDict, total=False):
    """Restaurant output for aggregating averages"""


class RestaurantSumAggregateOutput(TypedDict, total=False):
    """Restaurant output for aggregating sums"""


class RestaurantScalarAggregateOutput(TypedDict, total=False):
    """Restaurant output including scalar fields"""
    id: _str
    name: _str
    yelpId: _str
    latitude: _str
    longitude: _str


RestaurantMinAggregateOutput = RestaurantScalarAggregateOutput
RestaurantMaxAggregateOutput = RestaurantScalarAggregateOutput


class RestaurantMaxAggregateInput(TypedDict, total=False):
    """Restaurant input for aggregating by max"""
    id: bool
    name: bool
    yelpId: bool
    latitude: bool
    longitude: bool


class RestaurantMinAggregateInput(TypedDict, total=False):
    """Restaurant input for aggregating by min"""
    id: bool
    name: bool
    yelpId: bool
    latitude: bool
    longitude: bool


class RestaurantNumberAggregateInput(TypedDict, total=False):
    """Restaurant input for aggregating numbers"""


RestaurantAvgAggregateInput = RestaurantNumberAggregateInput
RestaurantSumAggregateInput = RestaurantNumberAggregateInput


RestaurantCountAggregateInput = TypedDict(
    'RestaurantCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'yelpId': bool,
        'latitude': bool,
        'longitude': bool,
        '_all': bool,
    },
    total=False,
)

RestaurantCountAggregateOutput = TypedDict(
    'RestaurantCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'yelpId': int,
        'latitude': int,
        'longitude': int,
        '_all': int,
    },
    total=False,
)


RestaurantKeys = Literal[
    'id',
    'name',
    'yelpId',
    'latitude',
    'longitude',
    'posts',
]
RestaurantScalarFieldKeys = Literal[
    'id',
    'name',
    'yelpId',
    'latitude',
    'longitude',
]
RestaurantScalarFieldKeysT = TypeVar('RestaurantScalarFieldKeysT', bound=RestaurantScalarFieldKeys)

RestaurantRelationalFieldKeys = Literal[
        'posts',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields